= Programmeren Basis - Deel 10
Frederiek De Wolf
v2021.10.15.12.47
// toc and section numbering
:toc: preamble
:toclevels: 4
:sectnums: 
:sectlinks:
:sectnumlevels: 4
// source code formatting
:prewrap!:
:source-highlighter: rouge
:source-language: csharp
:rouge-style: github
:rouge-css: class
// inject css for highlights using docinfo
:docinfodir: ../common
:docinfo: shared-head
// folders
:imagesdir: images
:url-verdieping: ../{docname}-verdieping/{docname}-verdieping.adoc
// experimental voor kdb: en btn: macro's van AsciiDoctor
:experimental:

//preamble
[.text-right]
versie {revnumber}

== Kleuren in de console aanpassen

Je kan in het __console scherm__ verschillende *voorgrond* en *achtergrond kleuren* gebruiken.

Door aan de `Console.BackgroundColor` en `Console.ForegroundColor` properties een kleur toe te kennen pas je deze instelling aan.

****
[.underline]#Voorbeeld met console kleuren#

Het achtergrond kleur wordt eerst op __groen__ ingesteld, de voorgrond daarna op __rood__.

[source,csharp,linenums]
----
Console.WriteLine("Hier zijn nog geen kleuren aangepast.");

Console.BackgroundColor = ConsoleColor.Green;
Console.WriteLine("De achtergrond is nu ingesteld op GROEN!");

Console.ForegroundColor = ConsoleColor.Red;
Console.WriteLine("De kleur op de voorgrond is aangepast in ROOD.");

Console.ResetColor();
Console.WriteLine("Nu werden de kleuren hersteld.");
----

Het console scherm zou er zo kunnen uitzien...

image:Console kleuren.png[Werken met aangepaste voorgrond en achtergrond kleuren.]
****

Zoals je merkt kan je voor het herstellen van de oorspronkelijke kleuren kan je altijd gebruikmaken van  `Console.ResetColor()`.

De naam van de kleur laat je voorafgaan door `ConsoleColor.`  

Een overzicht van de kleuren vind je hier...

image:Console kleuren - Overzicht.png[Console kleuren - Overzicht]

== Methods

=== Meermaals uitschrijven van dezelfde logica vermijden

Het valt soms voor dat een bepaald code fragment op verschillende plaatsen in je algoritme opduikt.
Het __meermaals uitschrijven van dezelfde logica__ is echter nooit een goed idee.  Het maakt de code immers *minder leesbaar* en *moeilijker te onderhouden*. 

Wens je aan dergelijke herhaalde logica iets aan te passen, dan moet dit op verschillende plaatsen gebeuren.  Dit is niet alleen een vervelend werk, het is ook foutgevoelig.  Daarom proberen we steeds *__DRY__* te werken (__Don't Repeat Yourself__), en dus *zo weinig mogelijk dezelfde code te gaan uitschrijven*.

==== Aan de hand van iteratiestructuren

Aan de hand van __iteratiestructuren __hebben we reeds herhalingen van logica vermeden. 

****
Indien een bepaald codefragment (bijvoorbeeld met __instructies B__, __C__ en __D__)  verschillende keren (na elkaar) wordt gebruikt, kan je aan de hand van  `do while`, `while`, `for` of `foreach` statements dit meermaals uitschrijven vermijden...

[%autowidth]
|====
|Zonder herhaling | Met herhaling

| image:Herhaling van logica vermijden - Zonder herhaling.png[Zonder herhaling.] | image:Herhaling van logica vermijden - Met herhaling.png[Met herhaling.]
|====
****

==== Aan de hand van extra methods

Indien de herhalingen niet opeenvolgend zijn, is een oplossing met  __iteratiestructuren__ niet steeds meer voor handen.  Wel kunnen we het meermaals uitschrijven van dezelfde code vermijden door dergelijke logica in een aparte __method__ te gaan definiëren.  

.Wat is een method?
[NOTE]
====
Een __method__ wordt één keer gedefinieerd, en verzamelt instructies.  Men spreekt ook wel over de __method definitie__.

De method kan meermaals worden aangeroepen (bij wijze van een __method call__).  Dit telkens wanneer de logica die ze vervat moet worden uitgevoerd...
====

We splitsen code af in een aparte method omdat we deze op verschillende plaatsen willen gebruiken, en *geen __copy/paste__* willen doen.
Copy/paste is altijd problematisch, als het stuk code ooit moet wijzigen, moeten we het op verschillende plaatsen aanpassen.  Het terugvinden van die plaatsen waar code nogmaals is herschreven is trouwens niet eenvoudig.  

****
Indien een bepaald code fragment (bijvoorbeeld met __instructies I__ en __J__)  op verschillende plaatsen wordt gebruikt, kan je aan deze verschuiven naar een `ExtraMethod`.  Deze extra method kan vervolgens worden aangeroepen...

[%autowidth]
|====
|Zonder extra method | Met extra method

| image:Herhaling van logica vermijden - Zonder methods.png[Zonder extra method.] | image:Herhaling van logica vermijden - Met methods.png[Met extra method.]
|====

Het code fragment wordt niet meer meermaals uitgeschreven, enkel de aanroep naar de extra method wordt nog herhaald.  
****

Indien een method wordt aangeroepen (met een zogenaamde __method call__) wordt de code van deze method uitgevoerd.  Na afloop wordt teruggekeerd naar de plaats van aanroep, en wordt de code die volgt op de method call vervat.

.Console applicaties starten bij de `Main` method.
[NOTE]
====
Tot dus ver hebben we alles uitgeschreven aan de hand van één method.  Meer specifiek de __hoofdmethod__, waar ons programma start.  

Deze hoofdmethod krijgt altijd de naam `Main`.  Een __console applicatie__ start steeds bij deze __hoofdmethod__. 
====

=== Code structureren
			
Code afsplitsen in aparte methods heeft ook als voordeel dat we er zo *een naam op kunnen plakken*.  

Door code weg te schuiven (naar de method definitie) en te vervangen door een eenvoudige method call, kunnen 
we ons beter concentreren op een bepaald abstractieniveau.  We worden niet meer verstrooid door allerhande technische details.  

Het maakt de code (waar we de methods aanroepen) eenvoudiger en leesbaarder.  

****
[.underline]#Conversie voorbeeld - Alles samen#

We wensen een eenvoudige console applicatie die ons de mogelijkheid laat __inches naar centimeters__, of het omgekeerde (__centimeter naar inches__) om te zetten.  

Het programma moet een menu aanbieden met de voorziene opties...

[source,shell]
----
Omzetting:
1) centimeter -> inch
2) inch -> centimeter
Keuze (1/2)?: 2             
----

Indien de gebruiker hier bijvoorbeeld voor __2__ had gekozen, en op kbd:[ENTER] drukt, dient zij/hij vervolgens een __om-te-zetten waarde__ in te voeren...

[source,shell]
----
Om-te-zetten waarde?: 10
10 inch is 25,4 centimeter.
Druk op <Enter> om nog een afstand om te zetten...             
----

Bij invoer van __10__ toon het programma het omgezette resultaat, en biedt het de mogelijkheid overnieuw te beginnen.

Onderstaande code werd daarvoor in eerste instantie opgesteld...

Focus niet teveel op de details maar laat je alvast opvallen hoe:

- Alles samen in één method is gepropt.  De code voor het __afprinten van een menu__, __een keuze laten invoeren__, __weergeven van een foutmelding over de invoer__,  __omzetten van de ingevoerde waardes__, ..., staat allemaal samen.
- Bepaalde code fragmenten worden zelfs meermaals uitgeschreven.  Zo wordt een tweetal keer op bijna identieke wijze een foutmelding weergegeven.

[source,csharp,linenums]
----
static void Main() {
    Console.ResetColor();
    do {
        string menuOptie;
        bool fouteMenuKeuze;
        do {
            Console.Clear();
            Console.WriteLine("Omzetting:");
            Console.WriteLine("1) centimeter -> inch");
            Console.WriteLine("2) inch -> centimeter");
            Console.Write("Keuze (1/2)?: ");
            menuOptie = Console.ReadLine().Trim();
            fouteMenuKeuze = (menuOptie != "1") && (menuOptie != "2");

            if (fouteMenuKeuze) {
                Console.BackgroundColor = ConsoleColor.Yellow;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("Gelieve een bestaande menu-optie uit te kiezen!");
                Console.ResetColor();
                Console.Write("Druk op <Enter> om opnieuw te proberen...");
                Console.ReadLine();
            }
        } while (fouteMenuKeuze);

        double getal;
        bool fouteWaarde;
        do {
            Console.Clear();
            Console.Write("Om-te-zetten waarde?: ");
            fouteWaarde = !double.TryParse(Console.ReadLine(), out getal);

            if (fouteWaarde) {
                Console.BackgroundColor = ConsoleColor.Yellow;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("Gelieve een getal in te voeren!");
                Console.ResetColor();
                Console.Write("Druk op <Enter> om opnieuw te proberen...");
                Console.ReadLine();
            }
        } while (fouteWaarde);

        if (menuOptie == "1") {
            Console.WriteLine($"{getal} centimeter is {getal * 0.3937} inch.");
        } else if (menuOptie == "2") {
            Console.WriteLine($"{getal} inch is {getal * 2.54} centimeter.");
        }
        Console.Write("Druk op <Enter> om nog een afstand om te zetten...");
        Console.ReadLine();
    } while (true);
}
----
****

De code is weinig gestructureerd.  

Het is niet eenvoudig overzicht te verwerven in het het verloop van het programma.  En het is ook niet makkelijk meteen terug te vinden waar in de code je eventuele wijzigingen moet aanbrengen.

=== Method definitie

Meerdere methods kunnen in dezelfde __klasse__ (bijvoorbeeld `class Program`) worden gedefinieerd.  Klassen verzamelen de verschillende methods, bijvoorbeeld deze die tot een bepaald programma behoren.

De volgorde van deze methods in een klasse is vrij uit te kiezen.  Maar het is een goed idee met de hoofdmethod te starten.  Of op zijn minst de verschillende methods in een volgorde te plaatsen die overeenkomt met de volgorde waarin ze worden aangeroepen.

Hoe groter en complexer ons programma wordt, hoe vlugger je gaat focussen op het structureren van je code.

****
[.underline]#Conversie voorbeeld - Extra methods#

In ons voorgaand voorbeeld zou je bijvoorbeeld de code die zorgt voor het __afdrukken van het menu__ samen kunnen definiëren in een aparte method `PrintMenu`...

[source,csharp,linenums]
----
static void PrintMenu()
{
    Console.Clear();
    Console.WriteLine("Omzetting:");
    Console.WriteLine("1) centimeter -> inch");
    Console.WriteLine("2) inch -> centimeter");
    Console.Write("Keuze (1/2)?: ");
}
----
****

Extra methods worden, net zoals onze `Main` method, gedefinieerd met de `static void` sleutelwoorden in de hoofding.  De betekenis van deze sleutelwoorden wordt verderop besproken.

Op `static void` volgt de naam van de method.  Na de naam volgen ronde haakjes `()`.  Straks bespreken we hoe deze haakjes kunnen ingezet worden voor het doorgeven van informatie.

Tussen de accolades wordt de code geplaatst die moet worden uitgevoerd wanneer deze method wordt aangeroepen.

.Namen van extra method
[NOTE]
====
De naam omschrijft welke __functionaliteit__ de method zal vervullen.  Bijvoorbeeld __PrintMenu__,  __ToonFactuur__, __VerhoogSalaris__, __VerwijderWerknemer__.

Typisch start de naam van een method met een werkwoord in gebiedende wijs.
Vaak volgt op dit werkwoord een zelfstandig naamwoord die wat meer context geeft.

Denk ook aan voorgedefinieerde methods als `Write`, `WriteLine`, `ReadLine` of `ResetColor`.

Het is mogelijk in dezelfde klasse (bijvoorbeeld `class Program`) meerdere methods te definiëren met dezelfde naam.  Zolang er een verschil is in de parameters (type, aantal of volgorde) wordt dit toegestaan.  Het valt echter af te raden dit te doen, het brengt niets bij aan de uitdrukkingskracht van je code.
====

==== Waar moet ik extra methods plaatsen?

Voordien moest je de code van de oplossingen netjes tussen de accolades van de `Main` method plakken om een volledig en werkend programma te bekomen.

Vanaf hier gaan we met meerdere methods aan de slag.  De extra methods mogen samen met de `Main` method in de `class Program` worden ondergebracht.

De code in je __Visual Studio__ project zal er dus zo moeten uitzien :

[source, csharp, linenums]
----
using System;

namespace ConsoleApp1 {
    class Program {
		
        // Hier plaatsen we de Main method ...
        static void Main() {
           // ...
        }

        // Maar ook alle extra methods ...
		static void PrintMenu() {
           // ...
        }
	    // ...

	}
}
----

=== Method call

Daar waar nodig, kan je deze implementatie aanroepen aan de hand van een __method call__.  

Om dat te doen, vermeld je eenvoudigweg de naam van de method die je wenst aan te roepen.

****
[.underline]#Conversie voorbeeld - Gebruik van de extra method#

In onze `do { ... } while (fouteMenuKeuze);` loop, waar we tot dus ver begonnen met de code die __het menu ging afprinten__, kunnen we deze code vervangen door een __call__ naar onze `PrintMenu` method...

[source,csharp,linenums]
----
static void Main() {
    Console.ResetColor();
    do {
        string menuOptie;
        bool fouteMenuKeuze;
        do {
            PrintMenu(); // <1>
            menuOptie = Console.ReadLine().Trim();
            fouteMenuKeuze = (menuOptie != "1") && (menuOptie != "2");

            if (fouteMenuKeuze) {
                Console.BackgroundColor = ConsoleColor.Yellow;
                Console.ForegroundColor = ConsoleColor.Red;
                Console.WriteLine("Gelieve een bestaande menu-optie uit te kiezen!");
                Console.ResetColor();
                Console.Write("Druk op <Enter> om opnieuw te proberen...");
                Console.ReadLine();
            }
        } while (fouteMenuKeuze);

        ...
    } while (true);
}
----
<1> Hier wordt onze extra method `PrintMenu` aangeroepen.

De `Main` method is compacter geworden, en is zo beter leesbaar.  Meteen wordt bij het nalezen duidelijk dat de herhaling start met het __afprinten van een menu__.  Je hoeft niet meer de technische details te doorlezen vooraleer je zoiets doorhebt.

Let erop dat `PrintMenu` in dezelfde klasse (`class Program` in dit geval) is gedefinieerd als de `Main` method.  Voor alle duidelijkheid nog eens alle code van deze klasse samen...

[source,csharp,linenums]
----
class Program {
    static void Main() {
        Console.ResetColor();
        do {
            string menuOptie;
            bool fouteMenuKeuze;
            do {
                PrintMenu();
                menuOptie = Console.ReadLine().Trim();
                fouteMenuKeuze = (menuOptie != "1") && (menuOptie != "2");

                if (fouteMenuKeuze) {
                    Console.BackgroundColor = ConsoleColor.Yellow;
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("Gelieve een bestaande menu-optie uit te kiezen!");
                    Console.ResetColor();
                    Console.Write("Druk op <Enter> om opnieuw te proberen...");
                    Console.ReadLine();
                }
            } while (fouteMenuKeuze);

            double getal;
            bool fouteWaarde;
            do {
                Console.Clear();
                Console.Write("Om-te-zetten waarde?: ");
                fouteWaarde = !double.TryParse(Console.ReadLine(), out getal);

                if (fouteWaarde) {
                    Console.BackgroundColor = ConsoleColor.Yellow;
                    Console.ForegroundColor = ConsoleColor.Red;
                    Console.WriteLine("Gelieve een getal in te voeren!");
                    Console.ResetColor();
                    Console.Write("Druk op <Enter> om opnieuw te proberen...");
                    Console.ReadLine();
                }
            } while (fouteWaarde);

            if (menuOptie == "1") {
                Console.WriteLine($"{getal} centimeter is {getal * 0.3937} inch.");
            } else if (menuOptie == "2") {
                Console.WriteLine($"{getal} inch is {getal * 2.54} centimeter.");
            }
            Console.Write("Druk op <Enter> om nog een afstand om te zetten...");
            Console.ReadLine();
        } while (true);
    }
    static void PrintMenu() {
        Console.Clear();
        Console.WriteLine("Omzetting:");
        Console.WriteLine("1) centimeter -> inch");
        Console.WriteLine("2) inch -> centimeter");
        Console.Write("Keuze (1/2)?: ");
    }
}
----
****

Straks komen we terug op dit voorbeeld, en maken we het aan de hand van __nog een extra method__, nog compacter en nog beter gestructureerd.

=== Opvolgen van methodactivatie

Programma's worden opgebouwd door verschillende methods van elkaar gebruik te laten maken.  Eén method roept een andere op, die op zijn beurt nog een andere gaat aanroepen.
Eens de code in een aangeroepen method voltooid is, wordt teruggekeerd naar plaats van aanroep om daar weer verder te gaan.

Het helpt als lezer van de code goed te kunnen volgen hoe de __activatie__ van één method naar een andere overgaat.  Anders uitgedrukt, te kunnen volgen welke code op welk moment in uitvoering is.

Maar laten we het eerst nog eens zelf proberen het verloop van een programma, dat van meerdere methods gebruik maakt, op te volgen...

****
[.underline]#Voorbeeld van methods die andere methods aanroepen#

Neem onderstaande code over...

[source,csharp,linenums]
----
 1 : using System;
 2 : namespace VoorbeeldApp {
 3 :     class Program {
 4 :         static void Main() {                    // <1>
 5 :             PrintMenu();                        // <2> 
 6 :             Console.WriteLine("...");           // <10> 
 7 :         }
 8 :         static void PrintMenu() {
 8 :             PrintLijn();                        // <3>
10 :             PrintTitel();                       // <5>
11 :             Console.WriteLine("...keuzes...");  // <8>
12 :             PrintLijn();                        // <9>
13 :         }
14 :         static void PrintLijn() {
15 :             string lijn = new string('-', 50);  // <4>
16 :             Console.WriteLine(lijn);            
17 :         }
18 :         static void PrintTitel() {
19 :             Console.WriteLine("Voorbeeld App"); // <6> 
20 :             PrintLijn();                        // <7>
21 :         }
22 :     }
23 : }
----
	
...en probeer eens, nog vóór je onderstaand resultaat bekijkt, zelf te voorspellen welke uitvoer dit zal opleveren?

[source,shell]
----
?
----
<1> Uiteraard start het programma bij onze `Main` method.  
<2> Meteen wordt het menu afgedrukt (via `PrintMenu`).
<3> Hiervoor wordt eerst een lijn (via `PrintLijn`) afgedrukt.
<4> Een lijn afdrukken komt in dit geval neer op het afdrukken van een tekst bestaande uit 50 koppeltekens.  Eens deze code is voltooid, en de lijn dus werd afgedrukt, ...
<5> keert het programma terug naar plaats van aanroep (in `PrintMenu`), en gaat het verder met het afdrukken van de titel (via `PrintTitel`).
<6> De tekst __Voorbeeld App__ wordt afgedrukt, en...
<7> een nieuwe lijn wordt geprint (via een nieuwe call naar de `PrintLijn` method).  Eens deze titel is geprint, ...
<8> keert het programma terug naar plaats van aanroep (in `PrintMenu`), en worden de verschillende menu keuzes weergegeven.
<9> Daarna wordt overnieuw een lijn afgedrukt (via een nieuwe call naar de `PrintLijn` method).  Alle code van `PrintMenu` is uitgevoerd, dus...
<10> keert het programma bijgevolg terug naar plaats van aanroep (in `Main`), en drukt het programma om af te ronden nog drie puntjes af.

[source,shell]
----
--------------------------------------------------   // <1> <2> <3> <4>
Voorbeeld App                                        // <5> <6>
--------------------------------------------------   // <7>
...keuzes...                                         // <8>
--------------------------------------------------   // <9>
...                                                  // <10>
----

Methods `Main`, `PrintMenu` en `PrintTitel` worden elk één keer uitgevoerd.  De laatste twee hebben we in de code zelf aangeroepen.  De hoofdmethod (`Main`) wordt automatisch aangeroepen bij het opstarten van een __console applicatie__.

Method `PrintLijn` wordt in totaal drie keer aanroepen (en uitgevoerd).
****

Er bestaan in ontwikkelomgevingen tools (in __Visual Studio__ het __Call Stack__ toolvenster) om het verloop van deze activaties te kunnen opvolgen.  Deze helpen ons het overzicht te bewaren, of fouten op te sporen.
Later hebben we het wel eens over dat __Call Stack__ toolvenster.

=== Lokale variabelen

Elke method kan eigen lokale variabelen hebben.  De __scope__ van deze variabelen is beperkt tot deze method, of zelf tot het __kleinst omvattende code block__ (de dichtst omsluitende accolades).

De scope van een variabele is het bereik in dewelke je van deze variabele gebruik kan maken.

Methods mogen dezelfde namen voor variabelen gebruiken, er is geen verwarring mogelijk.  
		
****
[.underline]#Voorbeeld van Step Over en Out#
	
Een variabele `x` in de `Main` method heeft *niets te maken* met een variabele `x` in `MethodA`...
		
[source,csharp,linenums]
----
static void Main() {
	int x = 9;
	
	Console.WriteLine($"De waarde van x in Main, voor oproep MethodA is {x}.");
	MethodA();
	Console.WriteLine($"De waarde van x in Main, na oproep MethodA is {x}.");
}

static void MethodA() {
	int x = 20;
	
	Console.WriteLine($"De waarde van x in MethodA is {x}.");
}
----

De uitvoer is...

[source,csharp,linenums]
----
De waarde van x in Main, voor oproep MethodA is 9.
De waarde van x in MethodA is 20.
De waarde van x in Main, na oproep MethodA is 9.  // <1>
----
<1> De waarde van `x` in `Main` blijft __9__.
****

Methods kunnen *niet* aan elkaars lokale variabelen.  Daarom noemen we ze ook __lokaal__.

=== Parameters

Bij het oproepen van een method kunnen we hem extra informatie meegeven.  Informatie die door deze method kan worden ingezet om zijn taken te vervullen.

Dit doen we aan de hand van __parameters__ (ook wel __argumenten__ genoemd).  De informatie wordt tussen haakjes gezet bij de method oproep.  

[source,csharp,linenums]
----
Console.WriteLine("Hallo");	// <1> 
int getal = rnd.Next(1,11); // <2>
----
<1> Geeft __"Hallo"__ mee aan de oproep van de `WriteLine` method.
<2> Geeft de waarden __1__ en __11__ mee aan de oproep van de `Next` method.

De aangeroepen methods kunnen vervolgens aan de slag met de ontvangen informatie.  De `WriteLine` method zal de ontvangen informatie afdrukken op het de __console__.  De `Next` method zal een willekeurig getal tussen __1__ en __11__ opleveren.

In de definitie van de method geven we de parameters __namen__, en leggen hun __type__ vast.

****
[.underline]#Voorbeeld van een method met een parameter#

Wensen we van uit de `Main` method aan de `BegroetGebruiker` method een `voornaam` mee te geven, dan vermelden we die in de oproep tussen de ronde haakjes...

[source,csharp,linenums]
----
static void Main() {
	Console.Write("Geef uw voornaam?: ");
	string voornaam = Console.ReadLine();
	
	BegroetGebruiker(voornaam); // <1>
	
	//BegroetGebruiker(123);    // <3>
	//BegroetGebruiker();       // <4>
}

static void BegroetGebruiker(string gebruiker) { // <2>
	Console.WriteLine($"Welkom {gebruiker}, u bent nu aangemeld!");
}
----
<1> Bij het aanroepen van de `BegroetGebruiker` method moeten we een `string` meegeven, in dit geval geven we `voornaam` mee.
<2> Om een `string` te kunnen ontvangen moet onze method werken met een parameter van dat type.
<3> Compilefout: er wordt een `string` verwacht, en geen `int`.
<4> Compilefout: er wordt één waarde verwacht, deze is hier niet aanwezig.

De parameter van `BegroetGebruiker` is gedeclareerd van het type `string`, hierdoor wordt de aanroepende logica verplicht in `string` vorm een waarde op te geven.

Indien de gebruiker __Jan__ invoert, bekomen we...

[source,shell]
----
Geef uw voornaam?: Jan
Welkom Jan, u bent nu aangemeld!
----
****

.Welke naam kies ik voor mijn parameters?
[NOTE]
====
Merk op dat de naam van de parameter `gebruiker` van `BegroetGebruiker` niet gekoppeld is aan de variabele `voornaam` uit de `Main` method.  De variabelen hoeven dus niet dezelfde naam te hebben, maar dit mag wel. 
 
Voor de `BegroetGebruiker` method is de rol van de ontvangen waarde de __naam van de gebruiker__ die begroet moet worden.  De parameternaam `gebruiker` lijkt bijgevolg geen slechte keuze.
Voor de aanroepende logica kan deze __naam van de gebruiker__ bijvoorbeeld een `voornaam` zijn, maar net zo goed komt de __naam van de gebruiker__ uit een variabele `gast`, `user` of `admin`.

Het is met andere woorden niet zo dat omdat het in de context van de `Main` method gaat om een `voornaam`, dat `BegroetGebruiker` dan ook maar een gelijknamige parameter moet krijgen.

Baseer de namen van je parameters op de rol die de ontvangen waardes aannemen binnen de aangeroepen method.
==== 

Bij het aanroepen van een __geparameteriseerde method__ (een method met parameters) hoef je ook niet persé met variabelen te werken om de parameterwaarde op te geven.

****
[.underline]#Voorbeeld van meegeven van verschillende parameterwaardes#

Het kan ook aan de hand van expressies in andere vormen...

[source,csharp,linenums]
----
static void Main() {
	// Aan de hand van een literal expressie...
	BegroetGebruiker("administrator");      // <1>
	
	// Aan de hand van een samengestelde expressie...
	int gastNummer = 123;
	BegroetGebruiker("gast" + gastNummer);  // <2> 
	
	// Aan de hand van een call naar een andere method (die een waarde oplevert)...
	BegroetGebruiker(Console.ReadLine());   // <3>
}

static void BegroetGebruiker(string gebruiker) { 
	Console.WriteLine($"Welkom {gebruiker}, u bent nu aangemeld!");
}
----
<1> De tekst __"administrator"__ wordt meegegeven.
<2> De tekst __"gast123"__ wordt meegegeven.
<3> De __ingevoerde tekst__ wordt meegegeven.

Bij elke call naar `BegroetGebruiker` wordt hier één `string` meegegeven, dat is wat technisch gezien ook wordt verwacht.

Indien de gebruiker nu __Jan__ invoert, bekomen we...

[source,shell]
----
Welkom administrator, u bent nu aangemeld!
Welkom gast123, u bent nu aangemeld!
Jan
Welkom Jan, u bent nu aangemeld!
----
****

Zolang het datatype van de gebruikte expressie maar overkomt met deze van de gedeclareerde parametervariabele.

Dat was niet anders dan bij het gebruik van voorgedefinieerde methods.  Denk bijvoorbeeld aan iets als `int.Parse(Console.ReadLine())`.  

[discrete]
==== Meerdere parameters

Tot nu toe hadden we in onze eigen methods één parameter, maar dit kunnen er uiteraard meerdere zijn.  

Plaats komma's tussen de verschillend declaraties van parameters (in de definitie) of parameterwaardes (in de call).  

****
[.underline]#Voorbeeld van meerdere parameters#

Indien we af en toe van verschillende trekkingen de __lotto cijfers__ willen afdrukken, telkens ook voorafgegaan door een eigen omschrijving, kan een method als `PrintLottoCijfers` met een tweetal parameters van pas komen.

De eerste parameter is de reeks van __lotto cijfers__ die je wenst af te drukken.  De tweede parameter is de __omschrijving__ (of het `label`) dat bij het afdrukken vermeld wordt voor de cijfers...

[source,csharp,linenums]
----
static void Main() {
	int[] trekking1 = { 32, 10, 27, 21, 2, 13 };
	int[] trekking2 = { 10, 24, 34, 8, 19, 25 };
	
	PrintLottoCijfers(trekking1, "Trekking van gisteren");
	PrintLottoCijfers(trekking2, "Trekking van vandaag");
}

static void PrintLottoCijfers(int[] lottoCijfers, string label) {
	string cijfersInEénTekst = string.Join("|", lottoCijfers);
	Console.WriteLine($"{label}: {cijfersInEénTekst}");
}
----

Indien we het voorbeeld uitvoeren dan krijgen we volgende output...

[source,shell]
----
Trekking van gisteren: 32|10|27|21|2|13
Trekking van vandaag: 10|24|34|8|19|25
----

We worden verplicht twee argumentwaardes door te geven.  Een eerste van type `int[]` (__int array__), een tweede van type `string`.
****

[discrete]
==== Waarom parameteriseren

Niet altijd moet een method bij elke uitvoering __exact hetzelfde__ doen.  Soms merk je dat code __min of meer__ op dezelfde wijze meermaals is uitgeschreven.  

Indien het verschil hem zit in de waardes waarmee gewerkt wordt, liggen methods met parameters voorhanden.

****
[.underline]#Conversie voorbeeld - Extra method met parameters#

Het is je misschien opgevallen in ons __conversie voorbeeld (centimeter naar inches en omgekeerd)__ de instructies die de foutmeldingen tonen ook meermaals hadden uitgeschreven.

__Regels 11 tot en met 16__ en __regels 28 tot en met 33__ zijn zo goed als identiek.  

Enkel de tekst die wordt afgedrukt is verschillend.

[source,csharp,linenums]
----
 1 : ...
 2 : 
 3 : string menuOptie;
 4 : bool fouteMenuKeuze;
 5 : do {
 6 :     PrintMenu();
 7 :     menuOptie = Console.ReadLine().Trim();
 8 :     fouteMenuKeuze = (menuOptie != "1") && (menuOptie != "2");
 9 : 
10 :     if (fouteMenuKeuze) {
11 :         Console.BackgroundColor = ConsoleColor.Yellow;
12 :         Console.ForegroundColor = ConsoleColor.Red;
13 :         Console.WriteLine("Gelieve een bestaande menu-optie uit te kiezen!");
14 :         Console.ResetColor();
15 :         Console.Write("Druk op <Enter> om opnieuw te proberen...");
16 :         Console.ReadLine();
17 :     }
18 : } while (fouteMenuKeuze);
19 : 
20 : double getal;
21 : bool fouteWaarde;
22 : do {
23 :     Console.Clear();
24 :     Console.Write("Om-te-zetten waarde?: ");
25 :     fouteWaarde = !double.TryParse(Console.ReadLine(), out getal);
26 : 
27 :     if (fouteWaarde) {
28 :         Console.BackgroundColor = ConsoleColor.Yellow;
29 :         Console.ForegroundColor = ConsoleColor.Red;
30 :         Console.WriteLine("Gelieve een getal in te voeren!");
31 :         Console.ResetColor();
32 :         Console.Write("Druk op <Enter> om opnieuw te proberen...");
33 :         Console.ReadLine();
34 :     }
35 : } while (fouteWaarde);
36 : 
37 : ...
----

Bijvoorbeeld het __instellen van de foutmeldings-kleuren__, het __brengen van de foutmelding__, en het __resetten van de kleuren__, werd twee keer uitgeschreven.

Weliswaar één keer voor de melding __"Gelieve een bestaande menu-optie uit te kiezen!"__, en een andere keer met melding __"Gelieve een getal in te voeren!"__.

Een extra method als `PrintFoutmelding` met een parameter als `melding` kan hier helpen...

[source,csharp,linenums]
----
static void PrintFoutmelding(string melding)
{
    Console.BackgroundColor = ConsoleColor.Yellow;
    Console.ForegroundColor = ConsoleColor.Red;
    Console.WriteLine(melding);  // <1>
    Console.ResetColor();
    Console.Write("Druk op <Enter> om opnieuw te proberen...");
    Console.ReadLine();
}
----
<1> Deze keer wordt de inhoud van de parametervariabele afgedrukt.  Het zal de aanroepende logica zijn die bepaald om welke `melding` het juist gaat.

De ene keer kan `PrintFoutmelding` worden aangeroepen indien een __foutieve menu-keuze__ is gemaakt...

[source,csharp,linenums]
----
PrintFoutmelding("Gelieve een bestaande menu-optie uit te kiezen!");
----

De andere keer indien __er geen getal werd ingevoerd__...

[source,csharp,linenums]
----
PrintFoutmelding("Gelieve een getal in te voeren!");
----

Of nog eens alle code van `class Program` samen...

[source,csharp,linenums]
----
    class Program {
        static void Main() {
            Console.ResetColor();
            do {
                string menuOptie;
                bool fouteMenuKeuze;
                do {
                    PrintMenu();
                    menuOptie = Console.ReadLine().Trim();
                    fouteMenuKeuze = (menuOptie != "1") && (menuOptie != "2");

                    if (fouteMenuKeuze) {
                        PrintFoutmelding("Gelieve een bestaande menu-optie uit te kiezen!");  // <1>
                    }
                } while (fouteMenuKeuze);

                double getal;
                bool fouteWaarde;
                do {
                    Console.Clear();
                    Console.Write("Om-te-zetten waarde?: ");
                    fouteWaarde = !double.TryParse(Console.ReadLine(), out getal);

                    if (fouteWaarde) {
                        PrintFoutmelding("Gelieve een getal in te voeren!");                  // <2>
                    }
                } while (fouteWaarde);

                if (menuOptie == "1") {
                    Console.WriteLine($"{getal} centimeter is {getal * 0.3937} inch.");
                } else if (menuOptie == "2") {
                    Console.WriteLine($"{getal} inch is {getal * 2.54} centimeter.");
                }
                Console.Write("Druk op <Enter> om nog een afstand om te zetten...");
                Console.ReadLine();
            } while (true);
        }
        static void PrintMenu() {
            Console.Clear();
            Console.WriteLine("Omzetting:");
            Console.WriteLine("1) centimeter -> inch");
            Console.WriteLine("2) inch -> centimeter");
            Console.Write("Keuze (1/2)?: ");
        }
        static void PrintFoutmelding(string melding) {
			Console.BackgroundColor = ConsoleColor.Yellow;
			Console.ForegroundColor = ConsoleColor.Red;
			Console.WriteLine(melding);
			Console.ResetColor();
			Console.Write("Druk op <Enter> om opnieuw te proberen...");
			Console.ReadLine();
		}
	}
----
<1> `PrintFoutmelding` wordt aangeroepen voor `melding` __"Gelieve een bestaande menu-optie uit te kiezen!"__.
<2> `PrintFoutmelding` wordt aangeroepen voor `melding` __"Gelieve een getal in te voeren!"__.
****

Merk op dat onze `Main` method alvast een stukje eenvoudiger is geworden.  

Bij het bekijken van de code krijg je vrij vlug een beeld hoe het programma zal verlopen.  Je wordt niet meer verstrooid door de technische details van het __printen van de menu__ of het __printen van één of ander foutmelding__.

Wil je dan toch in die technische details duiken, dan kan dat uiteraard door naar de code te gaan kijken van de desbetreffende extra methods.

=== Return values

Een method kan een __waarde produceren__, of anders uitgedrukt: hij kan een *__waarde opleveren__*. 

Bijvoorbeeld...

[source,csharp,linenums]
----
string input = Console.ReadLine();  // <1>

Random rnd = new Random();
int getal = rnd.Next(1, 11);        // <2> 

Console.WriteLine(getal);           // <3>
----
<1> Method `ReadLine` produceert een `string` waarde.
<2> Method `Next` produceert een `int` waarde.
<3> Andere methods, zoals `WriteLine` leveren geen waarde op.

Het type van de waarde die geproduceerd wordt, wordt opgegeven in de method definitie.  
Men noemt dit het *__return type__* van de method.

Methods die geen waarde produceren, gebruiken `void` (Nederlands: __leegte__) in plaats van een return type om dat te signaleren.  

In de method zelf kun je aangeven wat de geproduceerde waarde is met een *__return statement__*.

De uitvoering van een method stopt meteen na deze return opdracht.  Waarna de uitvoering uiteraard, net als bij __void methods__, verder gaat net na de method oproep.

****
[.underline]#Voorbeeld van een method die een waarde oplevert#

In dit voorbeeld zal de `BodyMassIndex` method een `double` waarde opleveren.

[source,csharp,linenums]
----
static void Main()                                                   // <4>
{
	int kg = 47;
	int cm = 158;

	double bmi = BodyMassIndex(kg, cm);                              // <3>
	Console.WriteLine(bmi);

	//Of meteen:
	Console.WriteLine(BodyMassIndex(47, 158));                       // <3>
}
static double BodyMassIndex(int gewichtInKg, int lengteInCentimeter) // <2>
{
	double lengteInMeter = lengteInCentimeter / 100.0;
	double bmi = gewichtInKg / Math.Pow(lengteInMeter, 2);
	return bmi;                                                      // <1> 
}
----
<1> In de implemenatie van deze method wensen we graag een __bmi__ waarde (`double`) op te leveren.
<2> Om een `double` te kunnen opleveren (__returnen__) moeten we op de hoofding voor de methodnaam dat return type vermelden.  Op basis van die informatie weet de compiler hoe men deze method kan inzetten (oproepen).
<3> Gezien de `BodyMassIndex` method een `double` waarde oplevert, kan de call naar deze method als `double` expressie worden gebruikt.
<4> De `Main` method wil niets __returnen__, en wordt bijgevolg gemarkeerd als `void` method.

Indien we het voorbeeld uitvoeren dan krijgen we volgende output...

[source,csharp,linenums]
----
18,8271110398974
18,8271110398974
----
****

We gebruiken een `return` statement voor het opgeven van de op-te-leveren waarde.

Het sleutelwoord `return` moet uiteraard gevolgd worden door een expressie van hetzelfde datatype als het return type dat in de hoofding is vermeld.  In een `double` method moeten we bijvoorbeeld een `double` waarde opleveren.

[NOTE]
====
Zelfs in een `void` method kan je een `return` opdrachten opnemen.  Op het sleutelwoord `return` volgt dan geen waarde, dus bijvoorbeeld gewoon `return;`.

Dit beëindigt de method meteen en de uitvoering keert terug naar de plaats van oproep.  Je zou het kunnen vergelijken met wat een `break` doet voor een loop.
====

[discrete]
==== Return type van voorgedefinieerde methods

Indien je in de code editor van __Visual Studio__ met je muisaanwijzer hovert boven de naam van de method dan krijg je zijn __hoofding__ (ook wel __signatuur__ genoemd) te zien.

In die hoofding zie je voor de methodnaam staan wat het return type is van deze method.

In het geval van de `Console.ReadLine` method is dit inderdaad `string`...

image:Tooltip voor returntype van ReadLine.png[Tooltip voor returntype van ReadLine.]

Bij de `Random.Next` method is dat `int`...

image:Tooltip voor returntype van Next.png[Tooltip voor returntype van Next.]

`Console.WriteLine` produceert geen waarde, wat we inderdaad opmerken aan de hand van het `void` sleutelwoord...

image:Tooltip voor returntype van WriteLine.png[Tooltip voor returntype van WriteLine.]

Je merkt hoe zo'n __tooltips__ nuttige informatie kunnen opleveren.

=== Command versus Query

Er zijn dus twee soorten methods...

Methods die een resultaat produceren:: Dergelijke method wordt ook wel een *__query__* (Nederlands: __vraag__) genoemd.  De benaming __query__ is niet vreemd, je verwacht immers dat op een __vraag__ een __antwoord__ word geproduceerd.  Het __antwoord__ is dan de opgeleverde waarde.

- Deze methods leveren in hun implementatie een waarde op bij wijze van een `return` statement.  Ze hebben dus een __echt__ return type (dus geen `void`), die op hoofding voor de methodnaam wordt vermeld.

- Omdat deze methods een waarde opleveren, ga je ze typisch *als expressie aanroepen*, bijvoorbeeld in de veronderstelling dat `A` een `int` producerende method is, en method `B` een `string` return type kent: kan `A` en `B` overal gebruikt worden waar grammaticaal gezien respectievelijk een `int` of `string` expressie wordt verwacht...

	int getal1 = A();
	int getal2 = rnd.Next(1, A());
	int getal3 = 3 + A();
	int[] getallen = { 4, getal2, A() };
	string tekst = B();
	Console.WriteLine(B().ToLower());
	
- Queries krijgen vaak een naam die bestaat uit een zelfstandig naamwoord, of op zijn minst een naam die omschrijft __wat voor soort waarde__ wordt opgeleverd.  Bijvoorbeeld: __BodyMassIndex__.  Soms word een prefix __"Get"__ gebruikt (bijvoorbeeld __GetBodyMassIndex__).  Anderzijds zie je bij `bool` opleverende methods wel een de prefix __"Is"__.  __Conversie queries__ (om waardes om te zetten) krijgen dan typisch een __"To"__ prefix (bijvoorbeeld __ToLower__).
		
Method die [.underline]#geen# resultaten produceren:: Dergelijke method wordt ook wel een *__command__* (Nederlands: __opdracht__) genoemd.  De call naar zo'n method grijpt immers plaats als __het geven van een opdracht__.
		
- Leveren niets op, we gebruiken om dat te signaleren in de hoofding het `void` sleutelwoord in plaats van een return type.

- Omdat ze niets opleveren, worden ze niet als expressie aangeroepen.  De *call alleen vormt het statement*, bijvoorbeeld...

	C();
	D();
	
- Commands krijgen vaak een naam die bestaat uit een werkwoord (in gebiedende wijs), soms gevolgd door een zelfstandig naamwoord.  Het werkwoord geeft aan wat voor soort actie plaatsvindt (bijvoorbeeld __Write__, __Read__ of __Print__).  Het zelfstandig naamwoord verschaft wat meer context (bijvoorbeeld __WriteLine__ of __PrintQuotient__).

Kies ik voor een *command* of voor een *query*?::

De keuze voor één van de twee, __command__ of __query__ is niet moeilijk.  Denk steeds vanuit het perspectief van de __client code__ (de aanroepende logica).  __Hoe__ wil die gebruik gaan maken van je method:

- Wenst hij de method gewoon aan te roepen, bij wijze van opdracht om een stuk code op te starten?  Kies dan voor een __command__.

- Wenst hij eerder een vraag te stellen waar hij een antwoord op wil, of zal hij met andere woorden de method aanroepen als expressie?  Dan heb je duidelijk een __query__ nodig.

****
[.underline]#Voorbeeld van keuze voor command vs query#

In volgend stukje code schrijven we meermaals dezelfde __voorwaarde__ uit.  Een voorwaarde meer specifiek die nagaat of een bepaald jaartal (`jaar` of `volgendJaar`) een __schrikkeljaar__ is.

Het meermaals uitschrijven van dezelfde logica willen we vermijden.  Het maakt onze code, op zijn minst gezegd, moeilijker leesbaar.

[source,csharp,linenums]
----
static void Main()
{
	Console.Write("Jaar?: ");
	int jaar = int.Parse(Console.ReadLine());

	if (jaar % 400 == 0 || jaar % 4 == 0 && jaar % 100 != 0) {
		Console.WriteLine($"{jaar} is een schrikkeljaar.");
	} else {
		Console.WriteLine($"{jaar} is geen schrikkeljaar.");

		int volgendJaar = jaar + 1;
		if (volgendJaar % 400 == 0 || volgendJaar % 4 == 0 && volgendJaar % 100 != 0) {
			Console.WriteLine("Het jaar daarop is wel een schrikkeljaar.");
		}
	}
}
----

Voorwaarde...

`jaar % 400 == 0 || jaar % 4 == 0 && jaar % 100 != 0` 

...is zo goed als identiek aan...

`volgendJaar % 400 == 0 || volgendJaar % 4 == 0 && volgendJaar % 100 != 0`

Het enigste onderscheid zit hem in de waarde waarmee gewerkt wordt.  Dit maakt dat we dit meermaals uitschrijven kunnen vermijden door toevoeging van een extra method.  Dat telkens met een andere waarde wordt gewerkt, `jaar` of `volgendJaar`, is niet erg, we weten immers hoe we methods kunnen parametriseren.  

In beide `if` statements zouden we dus graag eerder een call gebruiken naar een method die __duidelijk maakt__ of `jaar` of `volgendJaar` al dan niet een __schrikkeljaar__ is.  Iets als...

[source,csharp,linenums]
----
static void Main()
{
	Console.Write("Jaar?: ");
	int jaar = int.Parse(Console.ReadLine());

	if (IsSchrikkeljaar(jaar)) {             // <1>
		Console.WriteLine($"{jaar} is een schrikkeljaar.");
	} else {
		Console.WriteLine($"{jaar} is geen schrikkeljaar.");

		int volgendJaar = jaar + 1;
		if (IsSchrikkeljaar(volgendJaar)) {  // <1>
			Console.WriteLine("Het jaar daarop is wel een schrikkeljaar.");
		}
	}
}
----
<1> De uitgeschreven voorwaarde is vervangen door een method call.

Aan de manier waarop deze method is aangeroepen (zijn grammaticale context) kan je afleiden dat het hier om een __query__ moet gaan.  Tussen de ronde haakjes na het `if` sleutelwoord wordt immers een __expressie__ verwacht.  Meer specifiek een `bool` expressie...

[source,csharp,linenums]
----
static bool IsSchrikkeljaar(int jaartal)
{
	return (jaartal % 400 == 0 || jaartal % 4 == 0 && jaartal % 100 != 0);
}
----

Dat het om __query__ gaat zal je allicht niet verwonderen.  De method zou een __antwoord__ moeten geven (bevestigend of ontkrachtend => `bool` als return type) op de *__vraag__* of een bepaald jaartal (de parameter) al dan niet een schrikkeljaar betreft. 
****

