= Programmeren Basis - Deel 11 - Oefeningen
Yanic Inghelbrecht
v2021.10.04.19.00
// toc and section numbering
:toc: preamble
:toclevels: 4
// geen auto section numbering voor oefeningen (handigere titels en toc)
//:sectnums:  
:sectlinks:
:sectnumlevels: 4
// source code formatting
:prewrap!:
:source-highlighter: rouge
:source-language: csharp
:rouge-style: github
:rouge-css: class
// inject css for highlights using docinfo
:docinfodir: ../common
:docinfo: shared-head
// folders
:imagesdir: images
:url-verdieping: ../{docname}-verdieping/{docname}-verdieping.adoc
:deel-04-oplossingen: ../deel-04-oplossingen/deel-04-oplossingen.adoc
:deel-07-oplossingen: ../deel-07-oplossingen/deel-07-oplossingen.adoc
:deel-09-oplossingen: ../deel-09-oplossingen/deel-09-oplossingen.adoc
// experimental voor kdb: en btn: macro's van AsciiDoctor
:experimental:

//preamble
[.text-right]
versie {revnumber}
 

== Methods


=== Oefening D11.letterscore
// Y10.07

Herschrijf link:{deel-04-oplossingen}#_oplossing_d04_score[de oplossing van D04.score] zodat het programma een method `GetLetterCodeForPercentage` gebruikt. Deze method heeft 1 parameter (het percentage) en retourneert de corresponderende lettercode.

De `Main` method ziet er dan zo uit :

[source,csharp,linenums]
----
static void Main() {
	Console.Write("Geef de score in % : ");
	string scoreAlsTekst = Console.ReadLine();
	int score = int.Parse(scoreAlsTekst);

	string letter = GetLetterCodeForPercentage(score); // <1>

	Console.WriteLine($"In Amerika is dat een \"{letter}\"");
}
----
<1> De enige wijziging in de `Main` method.


=== Oefening D11.kader
// Y10.03

Schrijf een method `ToonInKader` met 1 string parameter. Deze method toont de meegegeven string tussen sterretjes op de console.

Bijvoorbeeld, 
[source,csharp,linenums]
----
static void Main() {
    ToonInKader("Hallo");
}
----

produceert de volgende output op de console :

[source,shell]
----
*********
* Hallo *
*********
----

Je mag ervan uitgaan dat de tekst niet te lang is zodat het netjes (incl. sterretjes aan de zijkanten) in het console venster past.


=== Oefening D11.geenscheldwoordenarray
// Y1.09 (prg2)

Herschrijf link:{deel-09-oplossingen}#_oplossing_d09_geenscheldwoorden[de oplossing van D09.geenscheldwoorden] zodat het programma een method `IsAanvaardbaar` gebruikt. Deze method heeft 1 parameter (de tekst) en retourneert een `true` of `false` waarde al naargelang of de tekst aanvaardbaar is of niet.

De `Main` method ziet er dan zo uit :

[source,csharp,linenums]
----
static void Main() {
	Console.Write("Geef een tekst : ");
	string tekst = Console.ReadLine();

	bool isOk = IsAanvaardbaar(tekst); // <1>

	if (isOk) {
		Console.WriteLine("Tekst is aanvaardbaar");
	} else {
		Console.WriteLine("Tekst is niet aanvaardbaar");
	}
}
----
<1> de method oproep van `IsAanvaardbaar`.


=== Oefening D11.concataantalkeer
// Y10.02

Schrijf een method `ConcatAantalKeer` die 2 parameters heeft : een tekst en een aantal. Deze method produceert een string die de meegegeven tekst het gevraagde aantal keren bevat.

Bijvoorbeeld, 
[source,csharp,linenums]
----
static void Main() {
	string output = ConcatAantalKeer("*-", 4);
	Console.WriteLine( output );
}
----

Produceert de volgende output op de console :

[source,shell]
----
*-*-*-*-
----


=== Oefening D11.charcount
// Y1.03 (prg2)

Herschrijf link:{deel-07-oplossingen}#_oplossing_d07_aantalkeere[de oplossing van D07.aantalkeere] zodat het programma een method `GetCharCount` gebruikt. Deze method telt hoe vaak een bepaald karakter in een string voorkomt en retourneert dit aantal.

Een klein fragment dat de werking van deze method toont :

[source,csharp,linenums]
----
int aantal = GetCharCount("This is a local shop, for local people; there's nothing for you here..", 'o');
----
Na afloop zal `aantal` de waarde `8` bevatten.

Er is natuurlijk link:https://www.youtube.com/watch?v=meF7NmfnXZ0[nog een verband tussen deze opgave en die van oefening D07.07, window="_blank"].
	




=== Oefening D11.reversetext
// Y1.05 (prg2)

Schrijf een programma dat de gebruiker om een tekst vraagt en deze achterstevoren op het scherm zet.

Een mogelijke uitvoering waarbij de gebruiker `abcdefg` intypt.
[source,shell]
----
Geef een tekst : abcdefg
gfedcba
----
	
Schrijf en gebruik hiervoor een method `ReverseText` die je een string parameter en een string return type geeft.

Deze method bouwt een nieuwe string die de achterstevoren versie van de meegegeven tekst voorstelt. Deze nieuwe string is dan de return value van de method.


=== Oefening D11.palindroom
// Y1.04 (prg2)

Schrijf een programma dat de gebruiker om een woord vraagt en toont of dit woord een palindroom is. 

Een palindroom is een tekst die identiek is als je hem achterstevoren zet. Om het wat interessanter te maken : een lege tekst is geen palindroom en elke tekst van lengte 1 is wel een palindroom.

Enkele mogelijke uitvoeringen :

[source,shell]
----
	Geef een woord : bal
	False
----
[source,shell]
----
	Geef een woord : lol
	True
----
[source,shell]
----
	Geef een woord : parterretrap
	True
----
[source,shell]
----
	Geef een woord :
	False
----
	
Schrijf en gebruik hiervoor een method `IsPalindroom` met een string parameter en een bool return type. 

Deze method bepaalt of de meegegeven string al dan niet een palindroom is. De return value bevat het resultaat van deze check (`true` betekent wel palindroom, `false` betekent geen palindroom).







=== Oefening D11.clamped
// Y10.04

Schrijf een method `GetClamped` met 3 int parameters : min, getal en max. Het nut van deze method is dat ze altijd een waarde teruggeeft die tussen min en max ligt (grenzen incl.).

Deze method retourneert het volgende resultaat :

* `getal` indien `min \<= getal && getal \<= max`
** bv. `GetClamped(5, 8, 15)` produceert `8`
* `min` indien `getal < min`
** bv. `GetClamped(5, 2, 15)` produceert `5`
* `max` indien `getal > max`
** bv. `GetClamped(5, 33, 15)` produceert `15`

Probeer je oplossing uit met deze `Main` method :
[source,csharp,linenums]
----
static void Main() {
	Console.WriteLine("Voorbeeld GetClamped met min=3 en max=6");
	for (int i=1;i<=8;i++) {
		int clamped = GetClamped(3, i, 6);
		Console.WriteLine($"voor {i} geeft dit {clamped}");
	}
}
----

De output moet dan als volgt zijn :

[source,shell]
----
Voorbeeld GetClamped met min=3 en max=6
voor 1 geeft dit 3
voor 2 geeft dit 3
voor 3 geeft dit 3
voor 4 geeft dit 4
voor 5 geeft dit 5
voor 6 geeft dit 6
voor 7 geeft dit 6
voor 8 geeft dit 6
----

Dit __clampen__ komt van pas als je een waarde tot een bepaald gebied wil beperken (bv. een spelerspositie binnen het speelveld houden), maar link:https://www.youtube.com/watch?v=9KL50dk9C54[ook in het dagelijks leven,window="_blank"] kun je er vanalles mee doen.


=== Oefening D11.minmax
// Y10.01

Schrijf een programma dat een array met getallen definieert en vervolgens toont wat het kleinste en het grootste getal is in dat array. 

Schrijf hiervoor 2 methods, `BepaalMinimum` en `BepaalMaximum`, die beiden een array met getallen als parameter krijgen en resp het kleinste of grootste getal retourneren uit het meegegeven array.

De `Main` method ziet er zo uit :

[source,csharp,linenums]
----
static void Main() {
	int[] getallen = { -4, 7, 9, 34, 2, 56, 34, 78 };
	Console.WriteLine( BepaalMinimum(getallen) );
	Console.WriteLine( BepaalMaximum(getallen) );
}	
----
Je mag er in de beide methods van uitgaan dat het meegegeven array minstens 1 element bevat.


=== Oefening D11.bevatwaarde

Schrijf een programma dat de gebruiker om 5 unieke gehele getallen vraagt. 

* Het programma geeft met #1, ..., #5 aan om het hoeveelste getal het gaat
* Alle ongeldige input en dubbels worden genegeerd.
* Je mag ervan uitgaan dat de gebruiker geen `0` intypt. 

Achteraf toont het programma de 5 unieke getallen van de gebruiker, gescheiden door een komma.

Schrijf (en gebruik!) hierbij een bijkomende method `BevatWaarde` met 2 parameters : 

. een array met getallen
. een zoekgetal

De `BevatWaarde` method retourneert een true/false waarde, naargelang het zoekgetal wel/niet voorkomt in het array met getallen.

Plaats de unieke getallen van de gebruiker in een array en gebruik deze `BevatWaarde` method om dubbels te voorkomen.

Een mogelijke uitvoering :

[source,shell]
----
Geef getal #1 : 4
Geef getal #2 : hallo <1>
Geef getal #2 : -5
Geef getal #3 :       <1>
Geef getal #3 : 10
Geef getal #4 : 4     <2>
Geef getal #4 : -5    <2>
Geef getal #4 : 99
Geef getal #5 : 34
De unieke getallen zijn 4, -5, 10, 99, 34 
----
<1> ongeldige input werd genegeerd, de nummering verandert niet.
<2> dubbels werden genegeerd, de nummering verandert niet.

[IMPORTANT]
====
Waarom zou er in deze opgave staan __"Je mag ervan uitgaan dat de gebruiker geen 0 intypt"__? 

Probeer eens uit of je oplossing ook werkt als de gebruiker een `0` ingeeft. Zoniet, wat zou je kunnen veranderen om *alle* getallen toe te laten?
====


=== Oefening D11.getalinput
// Y10.08

Schrijf een method `GetGetal` met 2 parameters `min` en `max` (gehele getallen) die een int waarde oplevert.

Deze method vraagt de gebruiker om een getal tussen `min` en `max` (grenzen inclusief) en retourneert dit getal. 

Indien we te maken hebben met een rebelse gebruiker die geen getal intypt of een getal buiten de grenzen opgeeft (het lef!), dan herhaalt de method stoïcijns de vraag. Dit gaat door totdat de wil van de gebruiker gebroken is en hij braafjes doet wat ons programma hem opdraagt.

Gebruik deze `Main` method :
[source,csharp,linenums]
----
static void Main() {
    int getal = GetGetal(1,100);
    Console.WriteLine($"U koos voor {getal}");
}
----
Het programma zou dan de volgende output kunnen produceren :
[source,shell]
----
Geef een getal van 1 t.e.m. 100 : hallo
Geef een getal van 1 t.e.m. 100 : -1
Geef een getal van 1 t.e.m. 100 : 0
Geef een getal van 1 t.e.m. 100 : 103
Geef een getal van 1 t.e.m. 100 : watch?v=4Lk2KHajp4Y
Geef een getal van 1 t.e.m. 100 : Laat me toch gaan, rotprogramma!!
Geef een getal van 1 t.e.m. 100 : aaaargh!
Geef een getal van 1 t.e.m. 100 : 56
U koos voor 56, plooier
----
	
	
=== Oefening D11.filter

Hieronder staat een code fragment dat je zult moeten vervolledigen.

[source,csharp,linenums]
----
static void Main() {
	// Het array met waarden dat we als voorbeeld gebruiken
	int[] meetwaarden = { 3, 6, 10, -1, -23, 0, -6, 7, 10, -15, -4, 10 };

	// Een variabele voor de return value van een Filter method oproep
	int[] gefilterd;

	// Filter alle meetwaarden die tussen -4 en 7 liggen (grenzen inclusief)
	gefilterd = Filter(meetwaarden, -4, 7); // <1>
	
	Console.WriteLine(String.Join(",", gefilterd));
	// De output is : 3,6,-1,0,7,-4
	// Let erop dat de volgorde van de waarden in de output gelijk is aan
	// hun onderlinge volgorde in het 'meetwaarden' array!

	// Filter alle meetwaarden die tussen 10 en 10 liggen (grenzen inclusief)
	// (anders gezegd, hou enkel de tienen over).
	gefilterd = Filter(meetwaarden, 10, 10); // <1>
	
	Console.WriteLine(String.Join(",", gefilterd));
	// De output is : 10,10,10
	// Let erop dat de waarde 10 drie keer voorkomt omdat ze ook
	// drie keer voorkwam in het 'meetwaarden' array.

	// Filter alle meetwaarden die tussen 100 en 200 liggen (grenzen inclusief)
	gefilterd = Filter(meetwaarden, 100, 200); // <1>
	
	Console.WriteLine(String.Join(",", gefilterd));
	// De output is :
	// Let erop dat de output een lege regel is, er zijn immers geen
	// waarden tussen 100 en 200 in 'meetwaarden'. De lengte van
	// array 'gefilterd' is nu dus gelijk aan 0!}
}
----
<1> Op deze plaatsen wordt een `Filter()` method opgeroepen die je zelf zult moeten schrijven.

De `Filter()` method ziet er als volgt uit :

[source,csharp,linenums]
----
static int[] Filter(int[] getallen, int min, int max) {
	// TODO : code aanvullen
}
----

Deze method produceert een *nieuw* array en retourneert dit.

* Dit nieuwe array moet alle waarden uit parameter `getallen` bevatten die tussen de grenzen `min` en `max` liggen (grenzen inclusief). 
* De onderlinge volgorde van de waarden in dit nieuwe array is dezelfde als in het `getallen` array.
* Indien er geen enkele waarde tussen de grenzen gevonden wordt, dan retourneert de method een leeg array (dit is een array van lengte zero).

Vul de `Filter` method aan met de ontbrekende code, zodat het programma het beschreven gedrag vertoont. De code in de `Main` method dient om te testen, dus daar verander je niks aan.


=== Oefening D11.expand	

Hieronder staat een code fragment met vier voorbeelden en telkens de verwachte output (in commentaar) :

[source,csharp,linenums]
----
static void Main() {
	// voorbeeld 1 : een reeks één keer dupliceren
	int[] scores1 = { 2, 3, -5, 6 };
	int[] expanded1 = Expand(1, scores1); // <1>
	
	Console.WriteLine(String.Join(",", expanded1));
	// output is : 2,3,-5,6

	// voorbeeld 2 : een reeks drie keer dupliceren
	int[] scores2 = { 2, 3, -5, 6 };
	int[] expanded2 = Expand(3, scores2); // <1>
	
	Console.WriteLine(String.Join(",", expanded2));
	// de output is : 2,2,2,3,3,3,-5,-5,-5,6,6,6

	// voorbeeld 3 : een reeks nul keer dupliceren
	int[] scores3 = { };
	int[] expanded3 = Expand(0, scores3); // <1>
	
	Console.WriteLine(String.Join(",", expanded3));
	// output is : (een lege regel)
	// (de Expand oproep retourneerde immers een lege array)

	// voorbeeld 4 : een lege reeks 5 keer dupliceren
	int[] scores4 = { };
	int[] expanded4 = Expand(5, scores4); // <1>
	
	Console.WriteLine(String.Join(",", expanded4));
	// output is : (een lege regel)
	// (de Expand oproep retourneerde immers een lege array)
}
----
<1> Op deze plaatsen wordt een `Expand()` method opgeroepen die je zelf zult moeten schrijven.

De `Expand()` method ziet er als volgt uit :

[source,csharp,linenums]
----
static int[] Expand(int aantal, int[] getallen) {
	// TODO : code aanvullen
}
----

Deze method produceert een *nieuw* array en retourneert dit.

* Dit nieuwe array moet alle waarden uit parameter `getallen` bevatten, waarbij elke waarde een `aantal` keer gedupliceerd is.
** Bijvoorbeeld, de reeks 2, 3, -5, 6 via Expand 3x dupliceren geeft :
** 2, 2, 2, 3, 3, 3, -5, -5, -5, 6, 6, 6 (elk getal werd 3x herhaald)
* Je mag er van uitgaan dat aantal niet negatief is.
* De onderlinge volgorde van de waarden in dit nieuwe array is dezelfde als in het `getallen` array (maar ze kunnen dus meermaals voorkomen als `aantal > 1`).
* Indien `aantal == 0`, wordt een leeg array teruggegeven (dit is een array van lengte zero)

Vul de `Expand` method aan met de ontbrekende code, zodat het programma het beschreven gedrag vertoont. De code in de `Main` method dient om te testen, dus daar verander je niks aan.


=== Oefening D11.dierenwissenarray
	
We hernemen link:{deel-09-oplossingen}#_oplossing_d09_dierenwissen[de oplossing van D09.dierenwissen] :

[source,csharp,linenums]
----
string[] boerderijDieren = { "kip", "koe", "paard", "geit", "schaap" };

do {
	// toon alle dieren
	foreach (string dier in boerderijDieren) {
		if (dier == null) {
			// toon GEWIST als we een null tegenkomen
			Console.Write("GEWIST ");
		} else {
			Console.Write(dier + " ");
		}
	}
	Console.WriteLine();

	// vraag om een dier en bepaal de positie
	Console.Write("Welk dier wil je verwijderen : ");
	string tewissenDier = Console.ReadLine();
	int index = Array.IndexOf(boerderijDieren, tewissenDier);

	if (index != -1) {
		// wis dier
		boerderijDieren[index] = null;
	}

} while (true);
----

Voeg de nodige methods toe zodat de Main method er zo uitziet (en de oplossing nog steeds correct werkt natuurlijk) :

[source,csharp,linenums]
----
static void Main() {
	string[] boerderijDieren = { "kip", "koe", "paard", "geit", "schaap" };

	do {
		toonDieren(boerderijDieren);
		wisDierVanGebruiker(boerderijDieren);
	} while (true);
}
----


=== Oefening D11.keuzeinput
// Y10.06

Schrijf een method `GetKeuze` die een parameter heeft van type string[]. 

De method vraagt de gebruiker een keuze te maken uit de meegegeven teksten.

De method blijft proberen totdat de gebruiker een geldige keuze maakt (hoofdletterONgevoelig) en retourneert de index van deze keuze.

Gebruik deze `Main` method :
[source,csharp,linenums]
----
static void Main() {
	string[] keuzes = {"Rood", "Groen", "Blauw"};
	int index = GetKeuze(keuzes);
	string kleur = keuzes[index];
	Console.WriteLine($"U koos {kleur}");
}
----

Een mogelijke uitvoering is :

[source,shell]
----
Geef uw keuze (Rood|Groen|Blauw) : geel
Geef uw keuze (Rood|Groen|Blauw) : 45
Geef uw keuze (Rood|Groen|Blauw) : 
Geef uw keuze (Rood|Groen|Blauw) : BLAUW
U koos Blauw
----


=== Oefening D11.reversearray
// Y10.09

Schrijf een method `Reverse` met een string[] parameter die de volgorde van de elementen in het array omkeert.

De `Main` method ziet er zo uit :

[source,csharp,linenums]
----
static void Main() {
	string[] test0 = { }; // Duizend bommen en granaten Kuifje, een leeg array!
	string[] test1 = { "een" };
	string[] test2 = { "een", "twee" };
	string[] test3 = { "een", "twee", "drie" };
	string[] test4 = { "een", "twee", "drie", "vier" };
	string[] test5 = { "een", "twee", "drie", "vier", "vijf"};
	
	string[] woorden = test0; // <1>
	
	Console.WriteLine( string.Join(", ", woorden) );
	Reverse(woorden);
	Console.WriteLine( string.Join(", ", woorden) );
}
----
<1> probeer je oplossing uit met de 6 verschillende test arrays!

Als we `test5` gebruiken ziet de output er zo uit :
[source,shell,linenums]
----
een, twee, drie, vier, vijf
vijf, vier, drie, twee, een
----	


=== Oefening D11.slice

Schrijf een method `Slice` met drie parameters :

* `int[] values`
* `int startIndex`
* `int length`

Deze method produceert een nieuw int array van lengte `length`, met daarin de waarden uit het originele `values` array vanaf positie `startIndex`.

Je mag ervan uitgaan dat `values` niet `null` is en dat `startIndex` een geldige positie is in dat array. Let op, de `length` parameter mag `0` zijn.

[source,csharp,linenums]
----
static void Main() {
	int[] getallen = { 0, 1, 2, 3, 4, 5, 6 }; // makkelijke getallen om te testen en te debuggen!

	int[] testHead0 = Slice(getallen, 0, 0);
	int[] testMiddle0 = Slice(getallen, 3, 0);
	int[] testTail0 = Slice(getallen, getallen.Length - 1, 0);

	int[] testHead1 = Slice(getallen, 0, 1);
	int[] testMiddle1 = Slice(getallen, 3, 1);
	int[] testTail1 = Slice(getallen, getallen.Length - 1, 1);

	int[] testHead2 = Slice(getallen, 0, 2);
	int[] testMiddle2 = Slice(getallen, 3, 2);
	int[] testTail2 = Slice(getallen, getallen.Length - 2, 2);

	int[] testComplete = Slice(getallen, 0, getallen.Length);

	int[] array = testHead0; // <1>

	string output = String.Join("-", array);
	Console.WriteLine(output);
}
----
<1> Probeer dit met alle test arrays uit

Het output gedeelte is eigenlijk tijdsverspilling als je alle test arrays wil checken. Zet gewoon een _breakpoint_ op regel <1> en kijk dan met de debugger naar de inhoud van de variabelen `testHead0` t.e.m. `testComplete` :
image:slice-check-lokale-variabelen.png[slice check lokale variabelen]

image:debug-smart.gif[debug smart]


=== Oefening D11.slicevariant

Als variant op de vorige oefening, schrijf dit keer een `Slice()` method waarbij de laatste parameter de eind index is i.p.v. de lengte :
[source,csharp,linenums]
----
static int[] Slice(int[] values, int startIndex, int endIndex) {
    ...
}
----
Deze `Slice` method produceert eveneens een nieuw array dat de getallen uit `values` bevat, maar dit keer vanaf positie `startIndex` tot aan positie `endIndex` (eindgrens niet inbegrepen).

De code van deze `Slice` mag de volgende veronderstellingen maken :

* parameter `values` is nooit `null`
* `startIndex \<= endindex`
* `startIndex` en `endIndex` zijn altijd geldige posities in array `values`

Je kan je oplossing uitproberen met de volgende `Main` method :
[source,csharp,linenums]
----
static void Main() {
	int[] getallen = { 34, 56, -89, 67, 100, -4, 34 };

	int[] kop = Slice(getallen, 0, 4);
	Console.WriteLine(String.Join("-", kop)); // toont 34, 56, -89, 67

	int[] staart = Slice(getallen, 3, 7);
	Console.WriteLine(String.Join("-", staart));  // toont 67, 100, -4, 34

	int[] midden = Slice(getallen, 2, 5);
	Console.WriteLine(String.Join("-", midden)); // toont -89, 67, 100

	int[] eentje = Slice(getallen, 2, 3);
	Console.WriteLine(String.Join("-", eentje));  // toont -89

	int[] leeg = Slice(getallen, 3, 3);
	Console.WriteLine(String.Join("-", leeg));  // toont niks
}
----


=== Oefening D11.encrypted

Hieronder staat een code fragment dat demonstreert hoe een `GetEncryptedCodeFor()` method werkt.

De code bevat enkele voorbeelden en toont de verwachte output in commentaar :

[source,csharp,linenums]
----
static void Main() {
	const string codewiel = "0ab1cd2ef3gh4ij5kl6m n7op8qr9st.uv,wx!yz?";


	string tekst = "a19z";
	string code = GetEncryptedCodeFor(tekst, codewiel, 5);

	Console.WriteLine("+ 5 " + tekst + "->" + code);
	// de output is  : + 5 a19z->2fv1

	tekst = "GROEN";
	Console.WriteLine("+ 5 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, 5));
	// de output is  : + 5 GROEN->GROEN
	
	tekst = "c# !";
	Console.WriteLine("+10 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, 10));
	// de output is  : +10 c# !->j#t2

	Console.WriteLine();

	tekst = "0allo?";
	Console.WriteLine("+ 1 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, 1));
	// de output is  : + 1 0allo?->ab66p0

	Console.WriteLine("+40 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, 40));
	// de output is  : +40 0allo?->?0kk7z

	Console.WriteLine("+41 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, 41));
	// de output is  : +41 0allo?->0allo?

	Console.WriteLine("- 1 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, -1));
	// de output is  : - 1 0allo?->?0kk7z

	Console.WriteLine();

	Console.WriteLine("-10 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, -10));
	// de output is  : -10 0allo?->.ueeit

	Console.WriteLine("-40 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, -40));
	// de output is  : -40 0allo?->ab66p0

	Console.WriteLine("-41 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, -41));
	// de output is  : -41 0allo?->0allo?

	Console.WriteLine("-82 " + tekst + "->" + GetEncryptedCodeFor(tekst, codewiel, -82));
	// de output is  : -82 0allo?->0allo?
}
----

Je ziet dat er bij elk voorbeeld, een method `GetEncryptedCodeFor()` wordt opgeroepen die een geheime tekst produceert als resultaat.

Elke oproep krijgt een `tekst` mee die moet omgezet worden naar geheimschrift (op basis van een `codewiel` en een getal dat de verschuiving voorstelt).

De `GetEncryptedCodeFor()` method ziet er als volgt uit :

[source,csharp,linenums]
----
        static string GetEncryptedCodeFor(string tekst, string codewiel, int offset) {
            // TODO : code aanvullen
        }
----

Hiervoor wordt een codewiel en een verschuiving gebruikt (de _offset_), je kunt link:https://www.feestideevoorjou.nl/code-kraken[de werkwijze hier nalezen].

In de Main method zie je hoe het codewiel wordt gedefinieerd, het is gewoon een `string` :

[source,csharp,linenums]
----
string codewiel="0ab1cd2ef3gh4ij5kl6m n7op8qr9st.uv,wx!yz?"
----

Stel dat we werken met een offset van +5 (i.e. we schuiven 5 posities naar rechts). Zowel het codewiel als de offset zijn parameters van deze method!

Om een tekst als `a19z` om te zetten naar een geheime code, wordt elk symbool van de originele `tekst` onderzocht :

* indien het symbool *niet* voorkomt in het codewiel,
** neem dan het symbool integraal over in het resultaat
* indien het symbool *wel* in het codewiel voorkomt,
** zoek op welke positie dit symbool in het codewiel staat
** schuif vervolgens 'offset' posities op naar rechts (of naar links indien `offset` negatief is)
** neem het symbool dat je op de nieuwe positie vindt en voeg dit toe aan het resultaat
*** als je bij het schuiven over de rechterkant gaat, keer terug naar het begin en tel dan van daaruit verder naar rechts
*** als je bij het schuiven over de linkerkant gaat, ga naar het einde en tel dan van daaruit verder naar links

****
[.underline]#Voorbeeld#

Stel we willen de tekst `a19z` omzetten naar geheimschrift.

In dit voorbeeld gebruiken we codewiel van hierboven :

[source,csharp,linenums]
----
string codewiel="0ab1cd2ef3gh4ij5kl6m n7op8qr9st.uv,wx!yz?"
----

en we passen een verschuiving (= offset) van 5 toe.

We bepalen de geheime tekst als volgt :

* We beginnen met symbool `a`
** we vinden dit op positie `1` in het codewiel en schuiven `5` posities op naar rechts, waar we het symbool `2` vinden
** dus `a` wordt `2` in het resultaat
* We doen verder met symbool `1`
** we vinden dit op positie `8` in het codewiel, schuiven `5` posities op naar rechts en vinden daar een `f` symbool
** dus `1` wordt `f` in het resultaat
* We doen verder met symbool `9`
** we vinden dit op positie `28` in het codewiel, schuiven `5` posities op naar rechts en vinden daar een `v` symbool
** dus `9` wordt `v` in het resultaat
* Tenslotte doen we symbool `z`
** we vinden dit op positie `39` in het codewiel, schuiven 1 positie naar rechts en komen uit bij de rechterkant.
** We springen terug naar de linkerkant en schuiven nog 4 posities door naar rechts, waar we een `1` symbool vinden
** dus `z` wordt `1` in het resultaat

Deze bekomen tekst `2fv1` is dan de return value van de method en dit stelt de geheime code voor van tekst `a19z`.
****

Denk eraan dat de offset ook negatief kan zijn, dan schuif je gewoon op naar links (en springt evt. terug naar rechts als je de linkerkant bereikt).

Om het makkelijker te maken om je oplossing te checken a.d.h.v. de output, staat hieronder een voorbeeld uitvoering :

[source, shell]
----
+ 5 a19z->2fv1
+ 5 GROEN->GROEN
+10 c# !->j#t2

+ 1 0allo?->ab66p0
+40 0allo?->?0kk7z
+41 0allo?->0allo?
- 1 0allo?->?0kk7z

-10 0allo?->.ueeit
-40 0allo?->ab66p0
-41 0allo?->0allo?
-82 0allo?->0allo?
----


=== Oefening D11.eastboundanddown

Om je eens een idee te geven hoe een (relatief) ingewikkeld programma eruit ziet, staat hieronder de volledige broncode van het race spel.

Het is niet handig om dit in de browser te bekijken, dus kopieer de code naar je project in Visual Studio, zoals je voor alle andere oplossingen uit dit deel zou doen (zie instructies "Vooraf" bij de oplossingen).

De *bedoeling van deze oefening* is dat je zo goed mogelijk probeert te begrijpen wat er gebeurt in de broncode van dit spel. Er is dus niet echt een bijbehorende "oplossing".

Dit zal niet gemakkelijk zijn, ondanks dat er allerlei goeie programmeerprincipes toegepast werden :

* goeie namen gebruiken
* commentaar toevoegen om de bestaansreden van variabelen of het doel van lastige stukjes code uit te leggen
* lege regels gebruiken zodat er blokken ontstaan van opdrachten die samenhoren
* const variabelen gebruiken i.p.v. magic values
* liever een variabele teveel dan ene te weinig
* niet teveel doen op 1 regel
* etc.

[IMPORTANT]
====
De belangrijke les van deze oefening is : de meeste programma's zijn zo complex dat de 'eenvoudige' goeie programmeerprincipes niet volstaan om een programma overzichtelijk en begrijpbaar te maken.
====

Terwijl je deze code bestudeert (ja, werkelijk bestudeert!), kun je jezelf de volgende vragen stellen en experimenten uitproberen :

==== Toestand van de auto

Er is een enumeratie die de drie mogelijke toestanden van de auto voorstelt 

* Driving : we zijn aan het rijden
* Coasting : we zijn aan het uitbollen (benzine op)
* Stopped : we zijn stilgevallen (benzine op)

Waar staat die enumeratie in de code?

In welke variabele wordt de toestand van de auto bijgehouden?

==== Enkele simpele vragen

* Wat bepaalt dat de maximum snelheid `40` is?
** Waar in de code wordt verhinderd dat de snelheid groter dan `40` wordt?
* Wat bepaalt de lengte van de race (qua afstand)?
** Waar in de code wordt gecheckt of de finish bereikt werd?
* Wat bepaalt wanneer de benzine op is?
** Waar in de code wordt gecheckt of er wel/niet nog benzine is?

==== De bouw van het parcours

Wijzig de code zodat het array `roadOffsets` enkel nullen bevat en het array `halfRoadWidths` in alle slots de waarde `basicRoadWidth / 2` heeft.

* Start nu het spel, wat is er veranderd?
* Wat is de theoretische snelste tijd om de finish te halen?

Zorg ervoor dat `roadOffsets` nog steeds enkel nullen bevat, maar zorg ervoor dat `halfRoadWidths` weer de oorspronkelijke waarden bevat.

* Start nu het spel, wat is er veranderd?

Zorg er nu voor dat `halfRoadWidths` weer vol staat met de waarde `basicRoadWidth / 2` en dat `roadOffsets' terug de originele waarden bevat.

* Start nu het spel, wat is er veranderd?

Wat is je conclusie over de rol van de inhouden van `roadOffsets` en `halfRoadWidths`?

Zet nu de originele code terug zodat deze beide arrays weer hun originele invulling krijgen.



==== De game loop

Er is een gameloop die meermaals per seconde wordt opgeroepen. Op het einde van een race staat links bovenaan een getal, bv. `29.3 fps`. Dit is het gemiddeld aantal keren dat de gameloop per seconde werd uitgevoerd op je computer. 

Waar begint en eindigt de gameloop?

==== Bijhouden hoe ver we op het parcours zitten

Welke variabele houdt bij hoever we zitten op het parcours? 

Waar wordt die variabele gewijzigd? 

Waarom is het type van deze variabele `double` en niet `int`?

Wat gebeurt er als je per iteratie van de gameloop, deze variabele verhoogt met `5` i.p.v. de berekening?

Heeft de snelheidsindicatie dan nog enige betekenis?

Zet nu de originele berekening terug, zodat er bij de verplaatsing weer rekening gehouden wordt met de verstreken tijd (sinds de vorige update) en de snelheid van de auto.

==== Input afhandeling

Waar in de code wordt de input afgehandeld?

Welke variabele wijzigt als je op een links/rechts pijltjestoets duwt?

Waarom krijgt deze variabele de initiële waarde `-roadOffsets[0]`? Maak daar eens `0` van om te zien wat het effect is.

Zet nu de oorspronkelijke initiële waarde terug.

Waarom wordt in elke iteratie van de game loop de keyboard buffer leeggemaakt? 

Verwijder deze code eens en start het spel. Welk effect treedt erop als je stuurt?

Zet nu de code terug zodat de keyboard buffer weer wordt geleegd.

De framerate heeft gevolgen voor de sturing van de wagen :

* Als speler X het spel aan de bedoelde `30 fps` kan spelen, wat is dan de maximale links/rechts verplaatsing die de wagen per seconde kan maken? (*)

* Speler Y geraakt slechts aan `21 fps`, wat is dan de maximale links/rechts verplaatsing per seconde? (*)

(*) als het besturingssysteem tenminste de toetsdrukken snel genoeg kan aanleveren (zie verderop).

Is er voor deze beide spelers een verschil in moeilijkheid om de finish te bereiken? Waarom wel/niet?

==== Het scherm tekenen

Welke loop is verantwoordelijk voor het tekenen van het ganse scherm?

Voor elke lijn op het scherm wordt er een stukje van het parcours getekend. 

Er is een variabele die voor elke schermlijn, bijhoudt met welk deel van het parcours die lijn overeenkomt. Welke variabele is dit?

Waar wordt voor een schermlijn de roadOffset en halfRoadWidth opgezocht? Waarom staan daar die modulo (%) bewerkingen?

Waarom beweegt de ganse weg als we links/rechts sturen en niet het autootje?

Waar wordt voor een schermlijn het gras aan de linker- en de rechterkant van de weg getekend?

Start het spel en blijft meteen naar rechts sturen : het programma crasht na ongeveer een seconde. 

Waarom crasht het programma als we te ver van de weg afwijken? Geef de exception, op welke regel het foutloopt en waarom het foutloopt? 

Er zijn trouwens 2 manieren waarop het programma zo kan crashen, probeer het ook eens aan de andere kant van de weg ;)

Waarom ziet het gras er aan de overkant van de weg altijd groener uit? M.a.w. waarom ziet het gras er links en rechts niet hetzelfde uit?

Waarom moeten we de cursor niet telkens netjes op kolom `0` zetten (helemaal links) vooraleer we een schermlijn beginnen tekenen?

Bekijk de regel 

`road = new string(' ', spaces / 2) + roadMessage + new string(' ', spaces - spaces / 2);`

Waarom moeten er `spaces-spaces/2` spaties aan de rechterkant naast de `roadMessage` staan en niet gewoon `spaces/2`?

Iets gelijkaardigs gebeurt bij de berekening van variabele `spacesRightSide` verderop in de code bij 'Toon resultaat bericht' als de race is afgelopen.

==== De snelheid van de wagen

Waar in de code wordt bepaald of de auto op de weg staat?

Waarom staat daar iets i.v.m. `Char.IsLetterOrDigit()` en kijken we niet gewoon of het een spatie is?

Op welke 4 plaatsen wordt de snelheid van de wagen aangepast?

Waarom werd het woord `didn't` als `didnt` geschreven bij één van de mogelijke waarden voor `roadMessage`?

Waarom gaan we enkel over naar `Status.Stopped` als `speed < 1` *én* we tegelijkertijd aan het uitbollen zijn? Met de huidige instellingen rijdt de wagen zelfs op het gras nooit trager dan `6`, dus waarom niet enkel checken of `speed < 1`?

==== Frames en wachttijd

Om te zorgen dat het spel bij niemand sneller draait dan +- `30 fps` is er per iteratie van de game loop een wachttijd ingebouwd. Waarop is die wachttijd gebaseerd?

Haal de `Sleep` opdracht eens weg en speel het spel. Stijgt je fps waarde? 

Zet achteraf de `Sleep` opdracht terug.

Speler Z heeft een hele rappe computer (eentje met een Ferrari sticker op!) en speelt het spel aan `30fps` met `Sleep` en aan `50 fps` zonder `Sleep`. Veronderstel dat deze speler in beide gevallen perfect speelt en nooit in het gras terechtkomt, zal zij dan bij `50 fps` sneller de finish bereiken? Waarom wel/niet?

Dit spel is eigenlijk heel eenvoudig qua aantal bewerkingen per seconde. Elke laptop van de laatste 20 jaar zou dit spel aan `30 fps` moeten kunnen spelen. Het probleem zit hem bij de `Console.Write` commando's die nogal traag verlopen op sommige computers (ze waren ook nooit bedoeld om rap te zijn trouwens).

Momenteel doen we ongeveer 3 `Write` opdrachten voor elk van de 25 schermlijnen, dus al 75 `Write` opdrachten per frame. Wat we zouden kunnen doen, is één lange string bouwen die de inhoud van alle schermlijnen bevat en die string in één keer op het scherm zetten met 1 enkel `Write`. Dat zal de framerate zeer waarschijnlijk optrekken naar de bedoelde `30fps`. Het nadeel is dat we dan de kleuren moeten opgeven, die kun je niet in die ene lange string verwerken (tenzij misschien via ansi color codes, maar da's een heel ander verhaal).

De veranderingen die nodig om met 1 lange string te werken zijn relatief eenvoudig. Dus als je aan `21 fps` zit te spelen, zeker eens proberen!

==== Keyboard Properties

Waarom gebruiken we altijd `ReadKey(true)` en niet gewoon `ReadKey()`?

Vermits we met `ReadKey` gebruiken, is het aantal toetsaanslagen afhankelijk van de toetsenbord instellingen van je besturingssysteem. Zoek eens de instellingen 'Repeat delay' en 'Repeat rate' van het besturingssysteem.

Noteer de waarden (zodat je ze achteraf kan terugzetten!) en kijk wat het effect is van een lange 'Repeat delay' en een trage 'Repeat rate' op de sturing van de wagen.

Dat is de reden waarom je geen `ReadKey` zou gebruiken in een echt spel. Echte games leunen voor de input dichter aan bij de hardware (simpelweg : is de toets ingedrukt of niet) en omzeilen de ganse verwerking en buffering van het console venster.


==== Hallo, waar zijn de methods?!?

Misschien doe ik wel nog eens een poging om een versie met methods te maken, maar dit was eigenlijk bedoeld om

* jullie interesse te wekken door te tonen wat je al kan doen met de programmeertechnieken die we tot nu toe gezien hebben.
* als demonstratie van hoe een ingewikkelder programma eruit ziet (maar dit is eerlijk gezegd nog maar klein bier hoor).
* om jullie eens het gevoel te geven hoe het is, om een onbekend en ingewikkeld stuk code te leren begrijpen. In je latere programmeer carrière zul je dit heel vaak moeten doen.

==== Leuke uitbreidingen

Wie zich geroepen voelt om met de code aan de slag te gaan, een paar ideeën :

* Extra bezine oppikken onderweg
* Uitbollen na het bereiken van de finish i.p.v. meteen het spel te stoppen
* Obstakels op de weg plaatsen die de wagen vertragen (dat rijmt!)

==== Waarom heet dit spel 'Eastbound and down'?

Tja, waarom is de wagen zwart en staat er een gouden adelaar op de motorkap?

==== De broncode

En dan nu de broncode... (tromgeroffel)

[source,csharp,linenums]
----
enum Status { Driving, Coasting, Stopped };

static void Main(string[] args) {
	const string version = "v2020.11.02.22.00";
	const int intendedFrameRate = 30; // gewenst aantal frame per seconde
	const double idealMillisPerFrame = 1000 / intendedFrameRate;

	const int screenWidth = 120; // breedte van het speelscherm
	const int screenHeight = 25; // hoogte van het speelscherm
	const int screenMiddle = screenWidth / 2; // de kolom in het midden van het scherm

	const int finishDistance = 1000; // totale lengte van de race

	const double poweredAcceleration = 5; // versnelling als er nog benzine is
	const double offRoadDecelerationFraction = 0.9; // vertragingsfactor indien off-road
	const double unpoweredDecelerationFraction = 1.2; // vertragingsfactor indien benzine op is

	const double maxSpeed = 40;
	const double maxRaceTimeInSeconds = 31; // na deze tijd is de benzine op

	// Maak console venster klaar
	Console.Title = "Eastbound and down " + version;
	Console.CursorVisible = false;
	Console.ResetColor();
	Console.Clear();

	// Bouw een array dat de bochten in de weg bijhoudt,
	// dit zijn verschuivingen t.o.v. de middenlijn van een rechte weg.
	// Indien op index 36 een offset van -25 voorkomt, dan zal op afstand
	// 36 de weg 25 eenheden naar links verplaatst zijn
	const int numRoadOffsets = 100;
	const int roadOffsetVariance = 20;
	int[] roadOffsets = new int[numRoadOffsets];
	for (int i = 0; i < numRoadOffsets; i++) {
		roadOffsets[i] = Convert.ToInt32(Math.Round(roadOffsetVariance * Math.Cos(2 * Math.PI * i / numRoadOffsets)));
	}

	// Bouw een array dat (de helft van) de breedte van de weg bijhoudt.
	// Indien op index 36 een 13 voorkomt, dan is de weg op afstand 36
	// 2x13 eenheden breed.
	const int numRoadWidths = 125;
	const int basicRoadWidth = 20;
	const int roadWidthVariance = 4;
	int[] halfRoadWidths = new int[numRoadWidths];
	for (int i = 0; i < numRoadWidths; i++) {
		halfRoadWidths[i] = basicRoadWidth / 2 + Convert.ToInt32(Math.Round(roadWidthVariance / 2 * Math.Cos(2 * Math.PI * i / numRoadWidths)));
	}

	// Zet instructies op het scherm
	Console.WriteLine("Besturing gebeurt met de pijltjes toetsen links/rechts");
	Console.WriteLine("Kun je de finish halen vooraleer de benzine op is?");
	Console.WriteLine();
	Console.Write("Druk op een toets om te beginnen");
	Console.ReadKey(true);

	double raceTimeInSeconds; // houdt bij hoe lang de race al bezig is
	bool isSmokey = false; // voor de hele rappe ;)
	bool quit = false; // houdt bij of de gebruiker aangaf te willen stoppen
	while (!quit) {
		// IN ELKE ITERATIE VAN DEZE LOOP WORDT 1 RACE GEREDEN

		// Reset consolevenster (voor het geval gebruiker venstergrootte wijzigde tussen races)
		Console.SetWindowSize(screenWidth, screenHeight + 1);// extra ongebruikte regel om scrollen te vermijden
		Console.SetBufferSize(Console.WindowWidth, Console.WindowHeight);
		Console.ResetColor();
		Console.Clear();

		// Reset allerlei race data
		// .. afstand
		double distance = 0; // de reeds afgelegde afstand in deze race
		int distanceLeft; // hoeveel afstand is er nog te gaan tot aan de finish
		// .. auto
		int carPosition = -roadOffsets[0]; // de horizontale positie van de auto t.o.v. het midden van een denkbeeldige rechte weg
		Status carStatus = Status.Driving; // houdt bij wat de auto aan het doen is (rijden/uitbollen/gestopt)
		double speed = 0; // de snelheid van de auto
		// .. timing en frames
		long ticksAtStartOfRace = DateTime.Now.Ticks; // tijdsmeting bij het begin van deze race
		long ticksAtStartOfPreviousFrame = ticksAtStartOfRace; // tijdsmeting bij het begin van het vorige frame
		int frameCount = 0; // hoeveel frame werden er in deze race getekend

		do {
			// ELKE ITERATIE VAN DEZE LOOP IS EEN FRAME
			// Dit is de gameloop die meermaals per seconde wordt doorlopen
			// met (o.a.) de volgende taken :
			// - afhandeling input
			// - updaten van snelheid en afgelegde afstand
			// - hertekenen van het scherm
			// - tijdsmeting en checks


			// bereken tijdsverschil in ticks sinds vorige iteratie
			long ticksAtStartOfThisFrame = DateTime.Now.Ticks;
			long ticksDifference = ticksAtStartOfThisFrame - ticksAtStartOfPreviousFrame;
			ticksAtStartOfPreviousFrame = ticksAtStartOfThisFrame;

			// Bereken afgelegde afstand op basis van snelheid en verstreken tijd sinds vorige iteratie
			distance += (speed * ticksDifference / TimeSpan.TicksPerSecond);

			// Bereken de totale race tijd
			raceTimeInSeconds = Convert.ToDouble(ticksAtStartOfThisFrame - ticksAtStartOfRace) / TimeSpan.TicksPerSecond;

			// Check of benzine op is
			if (raceTimeInSeconds > maxRaceTimeInSeconds) {
				carStatus = Status.Coasting;
			}

			// Indien er een pijltjes toets werd ingedrukt, verplaats de wagen
			if (Console.KeyAvailable) {
				ConsoleKeyInfo cki = Console.ReadKey(true);
				if (cki.Key == ConsoleKey.LeftArrow) {
					carPosition++;
				} else if (cki.Key == ConsoleKey.RightArrow) {
					carPosition--;
				}

			}

			// maak keyboard buffer leeg
			// (er kunnen nog meer toetsdrukken inzitten en we willen niet dat die 'achterkomen')
			while (Console.KeyAvailable) {
				Console.ReadKey(true);
			}

			// Teken het ganse scherm
			Console.SetCursorPosition(0, 0);
			string bottomLine = ""; // onderste regel van het scherm moet onthouden worden
			for (int screenLine = 0; screenLine < screenHeight; screenLine++) {
				// DEZE LOOP HERTEKENT HET SCHERM, VAN BOVEN NAAR ONDER
				// ELKE ITERATIE TEKENT 1 VOLLEDIGE HORIZONTALE LIJN

				// Wat is de afstand (afgelegde weg) van deze lijn op het scherm
				int lineDistance = Convert.ToInt32(distance) + (screenHeight - screenLine);

				// Wat is de verschuiving van de weg op deze lijn?
				int offsetIndex = lineDistance % roadOffsets.Length;
				int lineOffset = roadOffsets[offsetIndex];

				// Wat is de breedte van de weg op deze lijn?
				int roadWidthIndex = lineDistance % halfRoadWidths.Length;
				int lineHalfRoadWidth = halfRoadWidths[roadWidthIndex];

				// Bereken de posities van de zijkanten van de weg
				int roadLeftPosition = carPosition + screenMiddle + lineOffset - lineHalfRoadWidth;
				int roadRightPosition = roadLeftPosition + 2 * lineHalfRoadWidth;

				// Teken de linkerkant naast de weg (gras)
				Console.BackgroundColor = ConsoleColor.DarkGreen;
				Console.ForegroundColor = ConsoleColor.Green;
				string leftSide = new string('#', roadLeftPosition); // programma crasht indien roadLeftPosition negatief is
				Console.Write(leftSide);

				// Bepaal of er een tekst op de weg moet komen
				string roadMessage = "";
				int lineDistanceToFinish = finishDistance - lineDistance;
				if (lineDistanceToFinish == 0) {
					roadMessage = "FINISH";
				} else if (lineDistance < 100 && lineDistance % 25 == 0) {
					roadMessage = "GO GO GO";
				} else if (carStatus == Status.Driving && lineDistance == finishDistance - 49) {
					roadMessage = "Epstein didnt";
				} else if (carStatus == Status.Driving && lineDistance == finishDistance - 50) {
					roadMessage = "kill himself";
				} else if (lineDistanceToFinish % 200 == 0) {
					roadMessage = lineDistanceToFinish.ToString();
				}

				// Teken de weg
				Console.ForegroundColor = ConsoleColor.White;
				string road;
				if (roadMessage.Length == 0) {
					Console.BackgroundColor = ConsoleColor.Gray;
					road = new string(' ', lineHalfRoadWidth * 2);
				} else {
					Console.BackgroundColor = ConsoleColor.DarkGray;
					int spaces = lineHalfRoadWidth * 2 - roadMessage.Length;
					if (spaces > 0) {
						road = new string(' ', spaces / 2) + roadMessage + new string(' ', spaces - spaces / 2);
					} else {
						road = roadMessage.Substring(0, lineHalfRoadWidth * 2);
					}
				}
				Console.Write(road);

				// Teken de rechterkant naast de weg (gras)
				Console.BackgroundColor = ConsoleColor.Green;
				Console.ForegroundColor = ConsoleColor.DarkGreen;
				int rightSideWidth = screenWidth - roadRightPosition;
				string rightSide = new string('#', rightSideWidth); // programma crasht indien rightSideWidth negatief is
				Console.Write(rightSide);

				// onthou onderste lijn van het scherm zodat we na de loop nog kunnen checken
				// wat er onder de auto zit (i.e. de weg of gras)
				if (screenLine == screenHeight - 1) {
					bottomLine = leftSide + road + rightSide;
				}
			}

			// Check of de auto al dan niet op de weg staat (auto staat altijd op screenMiddle)
			int indexUnderCar = bottomLine.Length/2;
			char symbolUnderCar = bottomLine[indexUnderCar];
			bool isOffRoad = !(Char.IsLetterOrDigit(symbolUnderCar) || symbolUnderCar == ' ');

			// Bereken snelheidsverandering op basis van
			// - de ondergrond : op de weg of op het gras (off-road)
			// - of er nog benzine is of niet
			// rekening houdend met de verstreken tijd sinds de vorige iteratie (i.e. sinds vorige frame)
			if (isOffRoad) {
				speed -= (speed * offRoadDecelerationFraction) * ticksDifference / TimeSpan.TicksPerSecond;
			}
			if (carStatus == Status.Driving) {
				speed += poweredAcceleration * ticksDifference / TimeSpan.TicksPerSecond;
				// Zorg dat snelheid onder maxSpeed blijft
				speed = Math.Min(maxSpeed, speed);
			} else if (carStatus == Status.Coasting) {
				speed -= (speed * unpoweredDecelerationFraction) * ticksDifference / TimeSpan.TicksPerSecond;
				if (speed < 1) {
					carStatus = Status.Stopped;
				}
			}

			// Teken de auto
			Console.SetCursorPosition(screenMiddle, screenHeight - 1);
			if (isOffRoad) {
				Console.BackgroundColor = ConsoleColor.DarkRed;
			} else {
				Console.BackgroundColor = ConsoleColor.Black;
			}
			if (carStatus == Status.Driving) {
				Console.ForegroundColor = ConsoleColor.DarkYellow;
			} else {
				Console.ForegroundColor = ConsoleColor.DarkGray;
			}
			Console.Write("^");

			// Toon afstand en snelheid
			Console.SetCursorPosition(0, screenHeight - 1);
			Console.ForegroundColor = ConsoleColor.White;
			Console.BackgroundColor = ConsoleColor.DarkGreen;
			distanceLeft = finishDistance - Convert.ToInt32(distance);
			Console.Write($"{distanceLeft,4:d} {speed,2:f0}");

			// Wacht eventjes zodat volgende iteratie niet te snel komt. Dit beperkt de frame rate,
			// maar zorgt er ook voor dat de bewegingssnelheid links/rechts bij iedereen
			// ongeveer gelijk is (want de links/rechts verplaatsing gebeurt 1x per iteratie
			// dus hoe meer iteraties per seconde, hoe sneller je links/rechts zou kunnen
			// bewegen).
			long ticksAtEndOfThisFrame = DateTime.Now.Ticks; // tijdsmeting op het einde van dit frame
			double millisThisFrame = Convert.ToDouble(ticksAtEndOfThisFrame - ticksAtStartOfThisFrame) / TimeSpan.TicksPerMillisecond;
			int millisToWait = Convert.ToInt32(Math.Round(idealMillisPerFrame - millisThisFrame));
			System.Threading.Thread.Sleep(Math.Max(0, millisToWait));

			// tel deze frame
			frameCount++;

			// De race eindigt pas als de finish bereikt wordt of de auto stilvalt
		} while (distanceLeft > 0 && carStatus != Status.Stopped);

		// Bereken de gemiddelde framerate (zou +- gelijk moeten zijn aan 'intendedFrameRate')
		long ticksAtEndOfRace = DateTime.Now.Ticks;
		double averageMillisPerFrame = Convert.ToDouble(ticksAtEndOfRace - ticksAtStartOfRace) / TimeSpan.TicksPerMillisecond / frameCount;
		double averageFrameRate = 1000 / averageMillisPerFrame;

		// Toon de gemiddelde framerate
		Console.ForegroundColor = ConsoleColor.White;
		Console.BackgroundColor = ConsoleColor.Black;
		Console.SetCursorPosition(0, 0);
		Console.Write($"{averageFrameRate,0:f1} fps");

		// Maak resultaat bericht
		string resultMessage = " [SPACE = start, ESC = stop]";
		if (distanceLeft <= 0) {
			resultMessage = $"Finish bereikt na {raceTimeInSeconds,0:f2} seconden" + resultMessage;
			if (maxRaceTimeInSeconds - raceTimeInSeconds > 1) {
				// voor de hele rappe
				isSmokey = true;
				resultMessage += " [ENTER voor beloning]";
			}
		} else {
			resultMessage = $"Stilgevallen op {distanceLeft} van het einde" + resultMessage;
		}

		// Toon resultaat bericht
		int spacesNeeded = Console.WindowWidth - resultMessage.Length;
		int spacesLeftSide = spacesNeeded / 2;
		int spacesRightSide = spacesNeeded - spacesLeftSide;
		Console.SetCursorPosition(0, screenHeight - 1);
		Console.Write(new string(' ', spacesLeftSide));
		Console.Write(resultMessage);
		Console.Write(new string(' ', spacesRightSide));

		// Wacht tot de gebruiker een gepaste toets indrukt
		bool wait = true;
		while (wait) {
			ConsoleKeyInfo cki = Console.ReadKey(true);
			if (cki.Key == ConsoleKey.Spacebar) {
				wait = false;
			} else if (cki.Key == ConsoleKey.Escape) {
				wait = false;
				quit = true;
			} else if (cki.Key == ConsoleKey.Enter && isSmokey) {
				// voor de hele rappe
				var uri = "https://www.youtube.com/watch?v=jAG4XXCOj48&start=11";
				var psi = new System.Diagnostics.ProcessStartInfo();
				psi.UseShellExecute = true;
				psi.FileName = uri;
				System.Diagnostics.Process.Start(psi);
			}
		}

		// EINDE VAN ITERATIE VOOR DEZE RACE
	}
}
----



