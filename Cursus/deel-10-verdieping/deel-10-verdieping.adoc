= Programmeren Basis - Deel 10 - Verdieping
Frederiek De Wolf
v2021.10.15.12.48
// toc and section numbering
:toc: preamble
:toclevels: 4
:sectnums: 
:sectlinks:
:sectnumlevels: 4
// source code formatting
:prewrap!:
:source-highlighter: rouge
:source-language: csharp
:rouge-style: github
:rouge-css: class
// inject css for highlights using docinfo
:docinfodir: ../common
:docinfo: shared-head
// folders
:imagesdir: images
:url-verdieping: ../{docname}-verdieping/{docname}-verdieping.adoc
// experimental voor kdb: en btn: macro's van AsciiDoctor
:experimental:

//preamble
[.text-right]
versie {revnumber}
 
== Methods

=== Method overloading

Technisch gezien is het mogelijk in dezelfde klasse (bijvoorbeeld de `class Program`) meerdere methods te definiëren met dezelfde naam.  Men noemt dit ook wel __method overloading__.

Zolang er een verschil is in parameters (type, volgorde of aantal) blijft voor de compiler duidelijk welke method wordt aangeroepen.

****
[.underline]#Voorbeeld van method overloading#

	todo iets aanpassen aan start verwoording hier

Mogelijks wil je bij het laten __afprinten van de lotto cijfers__ geen specifiek `label` voorzien.  Volstaat het bijvoorbeeld dat voor de getallen de tekst __"Lotto Cijfers"__ wordt weergegeven...

[source,shell]
----
Lotto Cijfers: 32|10|27|21|2|13
Lotto Cijfers: 10|24|34|8|19|25
----

Voor dat doeleinde volstaat een method met slechts één parameter (`int[] lottoCijfers`), die we aanroepen als ...

[source,csharp,linenums]
----
PrintLottoCijfers(trekking1);
PrintLottoCijfers(trekking2);
----

Opnieuw is de naam `PrintLottoCijfers` uitgekozen, de __lotto cijfers__ worden ook door deze method immers __afgedrukt__.

Deze method kan eenvoudigweg herbruik maken van onze voorgaande `PrintLottoCijfers`.  Opnieuw gaat het ten slotte over het __afdrukken van de lotto cijfers__, deze keer met __"Lotto Cijfers"__ als `label`...

[source,csharp,linenums]
----
static void PrintLottoCijfers(int[] lottoCijfers) {
	PrintLottoCijfers("Lotto Cijfers", lottoCijfers); // <1>
}
----
<1> Let op dit is verwarrend: `PrintLottoCijfers` met één parameter roept `PrintLottoCijfers` met twee parameters aan.

Of alle code samen...

[source,csharp,linenums]
----
static void Main() {
	int[] trekking3 = { 4, 11, 25, 33, 7, 18 };
	
	PrintLottoCijfers(trekking3);
	PrintLottoCijfers(trekking3, "Trekking van dit weekend");
}

static void PrintLottoCijfers(int[] lottoCijfers, string label) {
	string cijfersInEénTekst = string.Join("|", lottoCijfers);
	Console.WriteLine($"{label}: {cijfersInEénTekst}");
}

static void PrintLottoCijfers(int[] lottoCijfers) {
	PrintLottoCijfers("Lotto Cijfers", lottoCijfers);
}
----

Indien we het voorbeeld uitvoeren dan krijgen we volgende output...

[source,shell]
----
Lotto Cijfers: 4|11|25|33|7|18
Trekking van dit weekend: 4|11|25|33|7|18
----
****

.Vermijd het gebruik van method overloading.
[WARNING]
====
Je merkt het: __method overloading__ kan al snel verwarrend werken.

Het valt dan ook af te raden __method overloading__ zomaar in te zetten.  Zeker in het geval dat de verschillende methods (met dezelfde naam) beduidend verschillende logica omvatten, is het geen goed idee.

Method overloading ondermijnt de leesbaarheid van de code.  De code wordt minder expliciet, verlies met andere woorden aan uitdrukkingkracht.  

Bij het nalezen van een method call is de naam alleen onvoldoen om af te leiden welke method nu precies wordt aangeroepen.  De lezer van de code moet ook nog eens naar de parameterwaardes gaan kijken.  De code is meer __ambigu__, wat nooit een pluspunt kan zijn.
====

Method overloading wordt in een aantal voorgedefinieerde methods gebruikt.  Denk aan de `Console.Write` of `WriteLine` methods die je met parameterwaardes van allerhande datatypes kan aanroepen.
Tik je in de code-editor van een geavanceerde ontwikkelomgeving als __Visual Studio__ de methodnaam in, dan toont __IntelliSense__ ons meteen een lijst van alle mogelijk aan te roepen overladen versies.

image::Visual%20Studio%20-%20Method%20Overloading%20Tooltip%201.png[Visual Studio - Method Overloading Tooltip 1]

Aan de hand van de pijltjes kan je scrollen tussen de verschillende versies van deze method.

Dat men voor al deze verschillende methods toch steeds kiest voor een naam als `WriteLine` of `Write`, is niet onlogisch.  Elk van die overladen methods gaat immers de parameterwaarde in tekstvorm op de console __schrijven__.
Het zou niet bepaald praktisch zijn indien men aan elke verschillende versie van de `WriteLine` of `Write` methods een andere naam zou geven.  
Maar opnieuw, wees er zuinig mee in je eigen code!

Bij het aanroepen van onze `PrintLottoCijfers` kregen we trouwens ook dergelijk tooltip te zien...

image::Visual%20Studio%20-%20Method%20Overloading%20Tooltip%202.png[Visual Studio - Method Overloading Tooltip 2]

== Parameters

=== Optionele parameterwaardes

In sommige gevallen kan je __method overloading__, en dus het uitschrijven van meerdere method definities, vermijden door te werken met __optionele parameters__.

Een optionele parameter krijgt een __default waarde__ die wordt ingezet wanneer de aanroepende logica geen ander waarde wenst te voorzien.

De aanroepende code heeft zo meer flexibiliteit, het kan ervoor kiezen al dan niet een waarde voor deze optionele parameter te voorzien

****
[.underline]#Voorbeeld van optionele parameter#

In dit voorbeeld gebruiken we voor de tweede parameter `label` de default waarde __"Lotto Cijfers"__.  

Wordt toch een tweede parameterwaarde doorgegeven, dan wordt deze default waarde met de doorgegeven waarde overschreven.

[source,csharp,linenums]
----
static void Main() {
	int[] trekking3 = { 4, 11, 25, 33, 7, 18 };
	
	PrintLottoCijfers(trekking3);                                // <3>
	PrintLottoCijfers("Trekking van dit weekend", trekking3);    // <4>
}

static void PrintLottoCijfers(int[] lottoCijfers, 
                              string label = "Lotto Cijfers") {  // <1>
	string cijfersInEénTekst = string.Join("|", lottoCijfers);
	Console.WriteLine($"{label}: {cijfersInEénTekst}");
}

//static void PrintLottoCijfers(int[] lottoCijfers) {            // <2>
//    PrintLottoCijfers("Lotto Cijfers", lottoCijfers);
//}
----
<1> Merk op dat aan de parameter `label` alvast een __default waarde__ wordt toegekend.
<2> Deze versie van `PrintLottoCijfers` is overbodig geworden.
<3> Hier wordt de defaultwaarde gebruikt.
<4> Hier wordt de defaultwaarde overschreven met de doorgegeven waarde.

Indien we het voorbeeld uitvoeren dan krijgen we volgende output...

[source,shell]
----
Lotto Cijfers: 4|11|25|33|7|18
Trekking van dit weekend: 4|11|25|33|7|18
----
****

.Optionele parameters achteraan de parameterlijst.
[NOTE]
====
Je mag met meerdere optionele parameters werken, maar deze moeten telkens achteraan de parameterlijst staan.
====

=== Parameterwaardes doorgeven met positie of naam

Tot nu toe was het steeds de positie van de parameterwaarde die bepaalde voor welke parameter deze waarde werd gebruikt.  

In volgend voorbeeld zal de eerste parameterwaarde `afstandInCm` (voor de komma) toegekend worden aan de parameter `deeltal`.
De tweede parameterwaarde __100__ (na de komma) wordt gebruikt voor parameter `deler`.

[source,csharp,linenums]
----
static void Main()
{
	double afstandInCm = 183;
	
	PrintQuotient(afstandInCm, 100);
}

static void PrintQuotient(double deeltal, double deler)
{
	Console.WriteLine(deeltal / deler);
}
----

Indien we het voorbeeld uitvoeren dan krijgen we volgende output...

[source,shell]
----
1,83
----

Toch kan je naast deze __parameter passing by position__ ook werken met *__parameter passing by name__*.

Vermeld hiervoor bij het aanroepen van de method tussen haakjes de naam van de parametervariabele.  Na de identifier zet je een `:` gevolgd door de parameterwaarde...

[source,csharp,linenums]
----
static void Main()
{
	double afstandInCm = 183d;
	
	PrintQuotient(deler: 100, deeltal: afstandInCm);
	PrintQuotient(afstandInCm, deler: 100);
}

static void PrintQuotient(double deeltal, double deler)
{
	Console.WriteLine(deeltal / deler);
}
----

Indien we het voorbeeld uitvoeren dan krijgen we volgende output...

[source,shell]
----
1,83
1,83
----

De volgorde van de parameterwaardes is niet meer van belang.
Deze aanpak kan de leesbaarheid ten goede komen.  Je hoeft niet meer te kijken naar de method definitie om een beeld te hebben van wat de rol is van deze parameterwaardes.

Je hoeft niet alle parameterwaardes te benoemen, maar benoemde moeten steeds achteraan de parameterlijst staan.
